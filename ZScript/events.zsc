// For generalized HaloDoom Events.
class HaloDoom_Events : EventHandler
{
	const TOK_EndOfLine = 13;
	bool nevertarget;
	bool alwaysautoaim;
	bool runningLZDoom;
	
	HaloDoom_EngineEvents engHandle;
	Dictionary surfacesDatabase;
	
	static Dictionary GetSurfacesData()
	{
		let haloEvents = HaloDoom_Events(EventHandler.Find("HaloDoom_Events"));
		if(haloEvents) return haloEvents.surfacesDatabase;
		return null;
	}
	
	override void OnRegister()
	{
		engHandle = HaloDoom_EngineEvents(StaticEventHandler.Find("HaloDoom_EngineEvents"));
				
		// Initialize footsteps
		surfacesDatabase = Dictionary.Create();
		PopulateFootsteps();
		runningLZDoom = !!CVar.GetCVar("vid_displaybits");
	}
	
	override void PlayerSpawned(PlayerEvent e)
	{
		if(halodoom_allpoweredup) GivePlayerPowerups(e.PlayerNumber);
	}
	override void PlayerRespawned(PlayerEvent e)
	{
		if(halodoom_allpoweredup) GivePlayerPowerups(e.PlayerNumber);
	}
	
	void GivePlayerPowerups(int pnum)
	{
		let plr = players[pnum];
		if(plr && plr.mo)
		{
			for(int i = 0; i < AllActorClasses.Size(); i++)
			{
				let classtype = AllActorClasses[i];
				if(classtype is "HaloPowerGiver" && classtype != "HaloPowerGiver") 
				{
					let power = (class<HaloPowerGiver>)(classtype);
					let defs = GetDefaultByType(power);
					if(!defs.bUPGRADEPOWER) continue;
					
					plr.mo.GiveInventory((class<Inventory>)(defs.powerupType), 1);
				}
			}
		}
	}
	
	void StringFilterEOL(out string src)
	{
		for(int i = src.Length(); i >= 0; i--)
			if(src.ByteAt(i) == TOK_EndOfLine) src.Remove(i,1);
	}
	void PopulateFootsteps()
	{
		// Read stepdefs 
		for(int lump = -1; (lump = Wads.FindLump("SURFDEFS", lump+1)) != -1;)
		{
			string data = Wads.ReadLump(lump);
			
			// Filter spaces, tabs, etc.
			data.Replace(" ", "");
			data.Replace("\t", "");
			data.Replace("\"", "");
			
			// Filter comments
			Array<String> lines;
			data.Split(lines, "\n");
			data = "";
			for(int i = 0; i < lines.Size(); i++)
			{
				string ln = lines[i];
				int comPos = ln.IndexOf("#");
				if(comPos >= 0) ln.Remove(comPos, ln.Length()-comPos);
				data.AppendFormat("%s", ln);
			}
			
			// Parse data
			Array<String> dataPoints;
			data.Split(dataPoints, "}");
			
			for(int i = 0; i < dataPoints.Size(); i++)
			{
				string defs = dataPoints[i];
				if(defs == "" || defs.Length() <= 0) continue;
				
				int argStart = defs.IndexOf("{");
				if(argStart < 0) 
					ThrowAbortException("STEPDEFS Error, expecting { following sound name.");
					
				string soundname = defs.Left(argStart);
				string textures = defs.Mid(argStart+1, defs.Length()-argStart);
				StringFilterEOL(soundname);
				
				// Read textures
				Array<String> textureNames; 
				textures.Split(textureNames, ",");
				
				for(int t = 0; t < textureNames.Size(); t++)
				{
					string texName = textureNames[t];
					StringFilterEOL(texName);
					
					surfacesDatabase.Insert(texName, soundName);
				}
			}
		}
	}
	
	override void WorldThingDamaged(WorldEvent e)
	{
		Actor source = e.DamageSource;
		if(source && source.target && source.bMISSILE) source = source.target;
				
		let victim = e.Thing;
		let dmgobj = e.Inflictor;
		if(!dmgobj) dmgobj = source;
		if(!dmgobj || !victim) return;
		
		bool headshot = HaloMath.CheckHeadshot(dmgobj, victim);
		
		// Play hit effects.
		HaloPlayer plr = HaloPlayer(source);
		if(plr)
		{
			uint plrnum = plr.PlayerNumber();
			String hitsnd =  headshot ? "Hit/Crit" : "Hit/Normal";
			if(plr.soundwait) hitsnd = "";
			
			Halo_OverlayUI.SendNetworkEvent(
				String.Format("hitmark:HitM_Normal:0:%s", hitsnd), 
				plrnum
			);
			if(!plr.soundwait) plr.soundwait = 2;
		}
		
		// Process damage-type effects.
		string dmgType = e.DamageType;
		dmgType = dmgType.MakeLower();
		
		if(dmgType.IndexOf("fire") != -1 && random[DMGTypeEffect](0,100) <= 20)
		{
			victim.GiveInventory("DamageFX_Fire", 1);
		}
	}
	
	override void WorldThingDied(WorldEvent e)
	{
		// Way to be a metric pain and for some stupid reason
		// not use the same parameters as WorldThingDamaged...
		let victim = e.Thing;
		let dmgobj = e.Inflictor;	
		if(!dmgobj && victim) dmgobj = victim.target;
		
		let source = dmgobj;
		if(source && source.bMISSILE) source = source.target;

		if(!dmgobj || !victim) return;
		
		bool headshot = HaloMath.CheckHeadshot(dmgobj, victim);
		
		// Play hit effects.
		HaloPlayer plr = HaloPlayer(source);
		if(plr)
		{
			uint plrnum = plr.PlayerNumber();			
			if(headshot)
				Halo_OverlayUI.SendNetworkEvent("hitmark:HitM_Headshot:1:Hit/Killed:replace", plrnum);
			else
				Halo_OverlayUI.SendNetworkEvent("hitmark:HitM_Killed:1:Hit/Killed:replace", plrnum);
		}
	}
	
	override void WorldTick()
	{
		let act_it = ThinkerIterator.Create();
		Actor act;
		while(act = Actor(act_it.Next()))
		{
			if(act.bISMONSTER && nevertarget && act.target is "HaloPlayer")
			{
				act.target = NULL;
			}
		}
	}

	override void NetworkProcess(ConsoleEvent e)
	{
		PlayerInfo src = players[e.Player];
		if(!src || !src.mo) return;
		let haloplr = HaloPlayer(src.mo);
		
		if(e.Name ~== "reload_gametype")
		{
			populateSpawnArrays();
			console.printf("Weapon Spawns reloaded based on current GameType.");
		}
		
		if(e.Name ~== "glitchgremlin")
		{
			Object.ThrowAbortException("\c[Red]Playsim aborted.");
		}
		
		// Extra keys
		if(haloplr && haloplr.health > 0)
		{			
			if(e.Name ~== "+weaponInfo") haloplr.drawWeaponInfo = true;
			if(e.Name ~== "-weaponInfo") haloplr.drawWeaponInfo = false;
			if(e.Name ~== "+icebeam")
			{
				let frzbeam = PowerFreezerBeam(haloplr.FindInventory("PowerFreezerBeam"));
				if(frzbeam) frzbeam.tryfire = true;
			}
		
			if(e.Name ~== "haveashield")
			{
				if(haloplr.aimActor)
				{
					ShieldProcessor.Attach(haloplr.aimActor);
					console.printf("Gave shield.");
				}
			}
				
			if(e.Name ~== "throwgrenade")
			{
				let haloweap = HaloGun(haloplr.player.ReadyWeapon);
				haloweap.ThrowCurrentGrenade();
			}
			if(e.Name ~== "nextgrenade")
			{
				haloplr.nextGrenade(true);
			}
			if(e.Name ~== "toggleflashlight")
			{
				if(haloplr.visor)
				{
					// Disable flashlight
					if(haloplr.flashlight && haloplr.flashlight.active) 
						haloplr.flashlight.active = false;
					
					haloplr.visor.SetEnabled(!haloplr.visor.enabled);
					string flStatus = haloplr.visor.enabled ? "ON" : "OFF";
					haloplr.A_StartSound("Halo/Visor/" .. flStatus, CHAN_AUTO);
				}
				else if(haloplr.flashlight) 
				{
					haloplr.flashlight.active = !haloplr.flashlight.active;
					string flStatus = haloplr.flashlight.active ? "ON" : "OFF";
					haloplr.A_StartSound("Halo/Flashlight/" .. flStatus, CHAN_AUTO);
				}
			}
		}
				
		Array<String> args;
		String cmd = e.Name;
		cmd.Split(args, ":");
		if(args[0] == "crosshairsummon" && haloplr)
		{
			class<Actor> obj = args[1];
			if(obj) Actor.Spawn(obj, haloplr.aimpos);
		}
		
		if(args[0] == "crosshairgive" && haloplr)
		{
			class<Inventory> item = args[1];
			if(!item || !haloplr.aimActor) return;
			
			haloplr.aimActor.GiveInventory(item, 1);
		}
		
		if(multiplayer && sv_cheats == 0) return;
		if(e.Name == "HaloDoom_GiveAll")
		{	
			Array<class<HaloGun> > guns;
			for(int i = 0; i < AllActorClasses.Size(); i++)
			{
				let classtype = AllActorClasses[i];
				if(classtype is "HaloGun" && classtype != "HaloGun") 
				{
					if(shouldFilterWeapon(classtype.getClassName())) continue;	
					guns.Push(AllActorClasses[i]);
				}
			}
			int spacing = 360./guns.Size();
			for(int i = 0; i < guns.Size(); i++)
			{
				let gun = guns[i];
				vector2 spawnpos = Actor.AngleToVector(i*spacing, 120);
				Actor.Spawn(gun, src.mo.Vec3Offset(spawnpos.x,spawnpos.y, src.mo.floorz));
			}
		}
		
		if(e.Name ~== "HaloDoom_SpawnHaloPowerups")
		{
			Array<class<HaloPowerGiver> > powers;
			for(int i = 0; i < AllActorClasses.Size(); i++)
			{
				let classtype = AllActorClasses[i];
				if(classtype is "HaloPowerGiver" && classtype != "HaloPowerGiver") 
				{
					powers.Push(AllActorClasses[i]);
				}
			}
			
			int spacing = 360./powers.Size();
			for(int i = 0; i < powers.Size(); i++)
			{
				let powerType = powers[i];
				vector2 spawnpos = Actor.AngleToVector(i*spacing, 80);
				Actor.Spawn(powerType, src.mo.Vec3Offset(spawnpos.x,spawnpos.y, src.mo.floorz));
			}
		}

		if(e.Name == "HaloDoom_GiveAllAmmo") // twosticksandarock
		{
			Array<class<Ammo> > gunAmmo;
			for(int i = 0; i < AllActorClasses.Size(); i++)
			{
				let classtype = AllActorClasses[i];
				if(classtype is "Ammo" && classtype != "Ammo") 
				{
					// Hacky way to define halodoom ammo because
					// the way Doom handles ammo is absolutely stupid.
					class<Inventory> ammoItem = (class<Inventory>) (classtype);
					let defs = GetDefaultByType(ammoItem);
					String iconSprite = TexMan.GetName(defs.Icon);
					if(iconSprite.IndexOf("HLAM") == -1) continue; 
					
					gunAmmo.Push(AllActorClasses[i]);
				}
			}
			int spacing = 360./gunAmmo.Size();
			for(int i = 0; i < gunAmmo.Size(); i++)
			{
				let ammoType = gunAmmo[i];
				vector2 spawnpos = Actor.AngleToVector(i*spacing, 80);
				Actor.Spawn(ammoType, src.mo.Vec3Offset(spawnpos.x,spawnpos.y, src.mo.floorz));
			}
		}
		
		if(e.Name == "HaloDoom_ArbiterCamo")
		{	
			nevertarget = !nevertarget;
			if(nevertarget) 
				console.printf("Camo is active, enemies will not target you.");
			else
				console.printf("Camo disabled.");
		}
		
		if(e.Name == "HaloDoom_AimHax")
		{	
			alwaysautoaim = !alwaysautoaim;
			if(alwaysautoaim) 
				console.printf("Autoaim switched to always active.");
			else
				console.printf("Autoaim now controller only.");
		}
		
		if(e.Name == "HaloDoom_MaxShield" && haloplr)
		{
			haloplr.shields = haloplr.maxshields * 3.0;
		}
	}
	
	// Key stuff
	override void WorldLinePreActivated(WorldEvent e)
	{
		let plr = HaloPlayer(e.Thing);
		if( !plr ) return;
		Line ln = e.ActivatedLine;
		
		// 13 is apparently the "locked" door special.
		bool locked = ln.special == 13; 
		if(!locked) return;
		
		// Check line key code.
		uint keyNum = ln.args[3]; 
		bool canOpen = false;
		String keyColor = "";
		[canOpen, keyColor] = CheckKey(plr, keyNum);
		
		// Add key to used keys if not already in list.
		bool usedKey = plr.cortana.usedKeys.Find(keyNum) != plr.cortana.usedKeys.Size();
		if(!usedKey) plr.cortana.usedKeys.push(keyNum);
			
		int cortanaMode = CVar.GetCVar("halodoom_cortanamode", plr.player).GetInt();
		
		// Queue door.
		let weap = HaloGun(plr.player.ReadyWeapon);
		if(canOpen && weap && !plr.pendingDoor)
		{
			plr.pendingDoor = ln;
			plr.pendingDoorColor = keyColor;
			e.shouldActivate = false;
			
			// Setup door animation
			switch(cortanaMode)
			{
				// Normal
				default: case 0: weap.CallMeleeState("Use_Cortana"); break;
				// Conditional
				case 1: if(!usedKey) weap.CallMeleeState("Use_Cortana"); break;
				// Off
				case 2: break; 
			}
		}
	}
	
	override void WorldLoaded(WorldEvent e)
	{
		populateSpawnArrays();
		if(!e.IsSaveGame)
		{
			// Clear used keys
			for(int i = 0; i < MAXPLAYERS; i++)
			{
				PlayerInfo plrInfo = players[i];
				if(!plrInfo || !playerInGame[i]) continue;
				let haloplr = HaloPlayer(players[i].mo);
				if(!haloplr) continue;
				
				// Clear keys
				haloplr.cortana.usedKeys.Clear();
				
				// Call weapon virtual(s)
				let haloweap = HaloGun(haloplr.player.ReadyWeapon);
				if(haloweap) haloweap.LevelLoaded();
			}
		}
	}
	
	bool hasKey(Actor src, string species)
	{
		// I'm really, really hating how Doom handles keys about now...
		class<Key> parentKey = species;
		for(let item = src.Inv; item; item = item.Inv)
		{
			if(!Key(item)) continue;
			if(item.species == species || item is parentKey) return true;
		}
		return false;
	}
	
	bool, string CheckKey(Actor src, int keyNum)
	{
		bool success = false;
		string keyCol = "";
		
		switch(keyNum)
		{
			case   1: if(hasKey(src, "RedCard"    )) success = true; keyCol = "Red";    break;
			case   2: if(hasKey(src, "BlueCard"   )) success = true; keyCol = "Blue";   break;
			case   3: if(hasKey(src, "YellowCard" )) success = true; keyCol = "Yellow"; break;
			case   4: if(hasKey(src, "RedSkull"   )) success = true; keyCol = "Red";    break;
			case   5: if(hasKey(src, "BlueSkull"  )) success = true; keyCol = "Blue";   break; 
			case   6: if(hasKey(src, "YellowSkull")) success = true; keyCol = "Yellow"; break;
			
			case 129: if(hasKey(src, "RedCard")    || hasKey(src, "RedSkull"   )) success = true; keyCol = "Red";    break;
			case 130: if(hasKey(src, "BlueCard")   || hasKey(src, "BlueSkull"  )) success = true; keyCol = "Blue";   break;
			case 131: if(hasKey(src, "YellowCard") || hasKey(src, "YellowSkull")) success = true; keyCol = "Yellow"; break;
		}
		
		return success, keyCol;
	}
}

class HaloDoom_EngineEvents : StaticEventHandler 
{		
	ui bool intro_played;

	override void UITick()
	{
		let curmenu = Menu.GetCurrentMenu();
		bool curintro = (curmenu is "HaloDoom_IntroSeq");
		bool titlescreen = (gamestate == GS_TITLELEVEL);
		
		if(!intro_played && !curintro && titlescreen)
		{
			Menu.SetMenu("Intro");
			intro_played = true;
		}
		else if(!titlescreen)
			intro_played = true;
	}
}