class GrapplingHook : KineLimb
{
	bool retracting;
	double lerp, spring_vel;
	
	vector3 fixedoffs;
	vector3 endpos;
	vector3 hookpos;
	
	Actor hitactor;
	PlayerPawn plr;
	
	
	double accel, maxspeed, maxdist;
	Property Setup : accel, maxspeed, maxdist;
	
	Default
	{
		GrapplingHook.Setup 70, 20, 512;
	}
	
	static bool CanDeploy(Actor source, vector3 offsets = (0,0,0))
	{
		let defs = GetDefaultByType("GrapplingHook");
		FLineTraceData hitdata;
		if(source.player) offsets.z += source.player.viewz-source.pos.z;
		source.LineTrace(source.angle, defs.maxdist, source.pitch, TRF_ALLACTORS, offsetz:offsets.z, offsets.x+64, offsets.y, data:hitdata);
		return !(hitdata.HitType == TRACE_HitNone || hitdata.HitType == TRACE_HasHitSky);
	}
	
	static GrapplingHook Deploy(PlayerPawn source, vector3 offsets)
	{
		if(!CanDeploy(source, offsets)) return null;
		
		let fRope = GrapplingHook(Spawn("GrapplingHook", source.pos));
		if(fRope)
		{
			fRope.plr = source;
			fRope.fixedoffs = offsets;
		}
		return fRope;
	}	
	
	override void OnCreate()
	{
		if(!plr) return;
		lerp = 0.1;
		GetRelPos();
		
		FLineTraceData lt;
		double zoffs = (plr.player.viewz-plr.pos.z) + fixedoffs.z;
		plr.LineTrace(plr.angle, 1024 * 32, plr.pitch, TRF_ALLACTORS, offsetz:zoffs, fixedoffs.x+64, fixedoffs.y, data:lt);	
		hookpos = lt.HitLocation;
		hitactor = lt.HitActor;
		
		plr.A_StartSound("Halo/Spartan/Grapple/Deploy", CHAN_BODY, CHANF_OVERLAP);
		PopulateSegs();
	}
	
	virtual void ClearSegs()
	{
		for(int i = segs.Size()-1; i >= 0; i--)
		{
			segs[i].Destroy();
			segs.Delete(i);
		}
	}
	
	virtual void Retract()
	{
		retracting = true;
		if(plr) 
		{
			plr.A_StopSound(CHAN_7);
			plr.A_StartSound("Halo/Spartan/ZipLine/End", flags:CHANF_OVERLAP);
		}
	}
	
	virtual void PopulateSegs()
	{
		for(int i = 0; i < 200; i++)
			AddSegment("RopeSegment");
	}
			
	virtual void GetRelPos()
	{
		fixedpos = HaloMath.RelativeV3Offset(plr, 0,0,0, fixedoffs.x, fixedoffs.y, fixedoffs.z, 1.0);
		followpos = endpos;
		
		if(hitactor)
			hookpos = hitactor.pos + (0,0, hitactor.height * 0.5);
	}
	
	override void Update()
	{
		endpos = HaloMath.Lerp3D(fixedpos, hookpos, lerp);
		GetRelPos();
		
		Actor src = plr;
		if(hitactor && HaloMath.GetInertia(hitactor.mass) >= 0.5)
			src = hitactor;
		
		vector3 diff = fixedpos-followpos;
		if(diff ~== (0,0,0)) return;
		double dist = diff.length();
		
		// Resize
		double segCount = segs.Size()-1;
		double segSize = dist / segCount;
		for(int i = 0; i < segCount; i++)
		{
			let seg = segs[i];
			seg.A_SetScale(seg.Scale.X, segSize);
		}
		
		// Retract
		if(retracting) 
		{	
			src.gravity = src.default.gravity;
			lerp -= 0.05;
			if(lerp <= 0.25)
			{
				ClearSegs();
				Destroy();
			}
			return;
		}
		
		// Extend and pull
		if(lerp < 1.0)
		{
			lerp += 0.067;
			if(lerp >= 1.0) 
			{
				A_StartSound("Halo/Spartan/Grapple/Latch", flags:CHANF_OVERLAP);
				src.A_StartSound("Halo/Spartan/ZipLine/Start", flags:CHANF_OVERLAP);
			}
		}
		else // Pull
		{
			diff = followpos-fixedpos;
			if(diff ~== (0,0,0)) return;
			vector3 dir = diff.Unit();
			
			if(src == plr)
			{
				uint btns = plr.player.cmd.buttons; 
				if(btns & BT_JUMP) 
				{
					plr.vel.z += 5;
					Retract();
					return;
				}
				if(btns & HaloPlayer.BT_GRAPPLE) 
				{
					Retract();
					return;
				}
			}
			else
			{
				dir = -dir;
			}
			
			// Spring physics
			spring_vel += HaloMath.DampedSpring(dist, 0, spring_vel, 4.5, 7);
			
			// Acceleration
			src.gravity = src.default.gravity * 0.25;
			double addspd = clamp(20 - spring_vel, 0, 70 / TICRATE);
			
			// Apply velocity
			dir.z *= 0.8;
			src.vel += dir * addspd;
			plr.A_StartSound("Halo/Spartan/ZipLine/Loop", CHAN_7, CHANF_OVERLAP|CHANF_LOOPING);
			
			if(dist <= 96) Retract();
		}
	}
}

class RopeSegment : Segment
{
	Default
	{
		YScale 1;
		XScale 1.5;
		
		RenderStyle "Normal";
		Translation "0:255=@80[0,0,0]";
	}

	override vector3 GetEndOffs()
	{
		return (Scale.Y,0,0);
	}
}