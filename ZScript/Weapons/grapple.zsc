
class GrapplingHook : Actor
{
	FLineTraceData hitdata;
	vector3 hitpos;
	vector3 pos_offs;
	Actor source;
	double spring_vel;
	double retract_spd;
	bool retracting;
	
	double maxspd, accel, mindist, maxdist;
	
	Property MaxSpeed_Accel_CloseDist : maxspd, accel, mindist, maxdist;
	
	Default
	{
		Radius 3;
		Height 2;
		Projectile;
		Scale 0.5;
		GrapplingHook.MaxSpeed_Accel_CloseDist 40, 60, 64, 700;
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if(other is "PlayerPawn") return false;
		return true;
	}
	
	vector3 GetOrigin()
	{
		vector3 offpos = HaloMath.V3Offset(angle, pitch, pos_offs.x, pos_offs.y, pos_offs.z, 1.);
		return level.vec3offset(source.pos, offpos);
	}
	
	static GrapplingHook Deploy(Actor source, double speed, vector3 offsets = (0,0,0), class<GrapplingHook> type = "GrapplingHook")
	{
		let gpl = GrapplingHook(Actor.Spawn(type, source.pos));
		if(gpl)
		{
			vector3 grapple_vel = HaloMath.VecFromAngles(source.angle, source.pitch, speed);
			gpl.pos_offs = offsets;
			gpl.angle = source.angle;
			gpl.pitch = source.pitch;
			gpl.vel = grapple_vel;
			gpl.retract_spd = speed;
			gpl.source = source;
		}
		return gpl;
	}
	
	void Retract()
	{
		if(!retracting) 
			SetState(FindState("Retract"));
	}
	
	override void Tick()
	{
		super.Tick();
						
		// Step in direction, spawn tail.
		vector3 origin = GetOrigin();
		double dist = (origin-pos).Length();
		
		if(dist > maxdist) Retract();
		
		double density = 10.;
		for(int i = 0; i < dist / density; i++)
		{
			vector3 head_diff = level.SphericalCoords(origin, pos, (angle, pitch));
			
			vector3 spawnpos = HaloMath.VecFromAngles (
				angle-head_diff.x,
				pitch-head_diff.y, 
				i*density
			);
			
			vector3 finalpos = level.vec3offset(origin, spawnpos);
			Spawn("GrappleHook_Tail", finalpos);
		}
	}
	
	States
	{
		Spawn:
			PLSS A 1;
		loop;
		
		Death:
			PLSS A 1 
			{
				// Get collision data
				LineTrace(angle, radius*radius, pitch, data:hitdata);
				vel *= 0;
				
				if(hitdata.HitType) 
				{
					hitpos = hitdata.HitLocation;				
					return ResolveState("DoGrapple");
				}
				else
				{
					return ResolveState("Retract");
				}	
			}
		goto DoGrapple;
		
		DoGrapple:
			PLSS A 1 
			{
				// If nothing was hit, don't grapple.
				if(!hitdata.HitType) return ResolveState(null);
				
				// Get unit vector facing accel direction.
				vector3 origin = GetOrigin();
				vector3 dir = (hitpos-origin).Unit();
			
				// Spring physics
				double spring_curpos = (origin - pos).Length();
				spring_vel += HaloMath.DampedSpring(spring_curpos, 0, spring_vel, 4.5, 7);
				
				// Acceleration
				double addspd = clamp(maxspd - spring_vel, 0, accel / TICRATE);
				
				// Apply velocity
				dir.z *= 1.50;
				source.vel += dir * addspd;
				
				// Remove grapple if source is close enough.
				double dist = (origin-pos).Length();
				if( dist <= mindist ) return ResolveState("Retract");
				
				// Continue
				return ResolveState(null);
			}
		loop;
				
		Retract:
			PLSS A 1 
			{
				bNOINTERACTION = true;
				A_ChangeLinkFlags(0, 0);
				vector3 head_diff = level.SphericalCoords(GetOrigin(), pos, (angle, pitch));
				vel = HaloMath.VecFromAngles(angle-head_diff.x, pitch-head_diff.y, -retract_spd);
				
				retracting = true;
			}
			TNT1 A 0 A_JumpIf( (GetOrigin()-pos).Length() <= 32, "Death.Real"); 
		goto Retract;
				
		Death.Real:
			TNT1 A 0;
		stop;
	}
}

class GrappleHook_Tail : Actor
{
	
	Default
	{
		Scale 0.1;
		+NOINTERACTION;
	}
	
	States
	{
		Spawn:
			PLSS A 2;
		stop;
	}
}
