class GrappleRopeTight : LaserBeam
{
	Default
	{
		Alpha 1.0;
		Scale 2.0;
		RenderStyle "Normal";
		Translation "0:255=@80[0,0,0]";
		
		LaserBeam.LaserColor "";
		LaserBeam.TrackWeapon false, 0;
		LaserBeam.AimFromWeapon true;
	}
}

class GrapplingHook : KineLimb
{
	bool retracting;
	double lerp, spring_vel;
	
	vector3 fixedoffs;
	vector3 endpos;
	vector3 hookpos;
	vector3 hitActPos;
	
	Actor hitactor;
	PlayerPawn plr;
	LaserBeam grappleTight;
	
	
	double accel, maxspeed, maxdist;
	Property Setup : accel, maxspeed, maxdist;
	
	Default
	{
		GrapplingHook.Setup 70, 20, 2048;
	}
	
	static bool CanDeploy(Actor source, vector3 offsets = (0,0,0))
	{
		let defs = GetDefaultByType("GrapplingHook");
		FLineTraceData hitdata;
		if(source.player) offsets.z += source.player.viewz-source.pos.z;
		source.LineTrace(source.angle, defs.maxdist, source.pitch, TRF_ALLACTORS, offsetz:offsets.z, offsets.x+64, offsets.y, data:hitdata);
		return !(hitdata.HitType == TRACE_HitNone || hitdata.HitType == TRACE_HasHitSky);
	}
	
	static GrapplingHook Deploy(PlayerPawn source, vector3 offsets)
	{
		if(!CanDeploy(source, offsets)) return null;
		
		let fRope = GrapplingHook(Spawn("GrapplingHook", source.pos));
		if(fRope)
		{
			fRope.plr = source;
			fRope.fixedoffs = offsets;
		}
		return fRope;
	}	
	
	override void OnCreate()
	{
		if(!plr) return;
		lerp = 0.1;
		GetRelPos();
		
		let lt = AimLineTracer.DoTrace(plr, plr.angle, plr.pitch, 1024 * 32);
	
		hookpos = lt.results.HitPos;
		hitactor = lt.results.HitActor;
		angle = 0.25;
		grappleTight = LaserBeam.Create(plr, fixedoffs.x,fixedoffs.y,fixedoffs.z, type:"GrappleRopeTight");
		
		if(hitactor) 
			hitActPos = HaloMath.DiffToLocal(hookpos, hitactor.pos, (hitactor.angle, hitactor.pitch));
		
		plr.A_StartSound("Halo/Spartan/Grapple/Deploy", CHAN_BODY, CHANF_OVERLAP);
		PopulateSegs();
	}
	
	virtual void ClearSegs()
	{
		for(int i = segs.Size()-1; i >= 0; i--)
		{
			segs[i].Destroy();
			segs.Delete(i);
		}
	}
	
	virtual void Retract()
	{
		retracting = true;
		if(plr) 
		{
			plr.A_StopSound(CHAN_7);
			plr.A_StartSound("Halo/Spartan/ZipLine/End", flags:CHANF_OVERLAP);
		}
	}
	
	virtual void PopulateSegs()
	{
		let complexity = CVar.GetCVar("halodoom_grapplecomplexity", plr.player);
		double segCount = max(20, 100 * complexity.getFloat());
		for(int i = 0; i <= segCount; i++)
			AddSegment("RopeSegment");
	}
			
	virtual void GetRelPos()
	{
		fixedpos = HaloMath.RelativeV3Offset(plr, 0,0,0, fixedoffs.x, fixedoffs.y, fixedoffs.z, 1.0);
		followpos = endpos;
		
		if(hitactor)
			 hookpos = hitactor.pos + hitActPos;
	}
	
	override void Update()
	{
		if(plr && plr.player && (plr.player.cheats & CF_PREDICTING)) return;
		
		endpos = HaloMath.Lerp3D(fixedpos, hookpos, lerp);
		GetRelPos();
		if(GetAge() >= 35*10) retracting = true;
	
		let haloplr = HaloPlayer(plr);
		uint btns = plr.player.cmd.buttons; 
		
		Actor src = plr;
		if(hitactor && HaloMath.GetInertia(hitactor.mass) >= 0.5)
			src = hitactor;
		
		vector3 diff = level.vec3diff(fixedpos, followpos);
		if(diff ~== (0,0,0)) return;
		double dist = diff.length();
		
		// Resize
		double segCount = segs.Size()-1;
		double segSize = dist / segCount;
		for(int i = 0; i <= segCount; i++)
		{
			let seg = segs[i];
			seg.A_SetScale(seg.default.Scale.X, segSize);
			seg.bInvisible = bInvisible;
			if(bInvisible) seg.A_SetScale(0);
		}
		
		// Retract
		if(retracting) 
		{	
			grappleTight.SetEnabled(false); 
			bInvisible = false;
			if(haloplr) 
			{
				haloplr.fricmod = 0; 
				haloplr.aircontrol = haloplr.default.aircontrol;
			}
			src.gravity = src.default.gravity;
			lerp -= 0.05;
			if(lerp <= 0.25)
			{
				ClearSegs();
				Destroy();
				haloplr.grapple = NULL;
			}
			return;
		}
		
		// Extend and pull
		if(lerp < 1.0)
		{
			lerp += 0.09;
			if(lerp >= 1.0) 
			{
				A_StartSound("Halo/Spartan/Grapple/Latch", flags:CHANF_OVERLAP);
				src.A_StartSound("Halo/Spartan/ZipLine/Start", flags:CHANF_OVERLAP);
				
				if(hitactor) hitactor.DamageMobJ(plr, self, 1, 'Grapple');
				src.vel.z += 2; // Provide inital Z boost.
			}
		}
		else // Pull
		{
			grappleTight.SetEnabled(true);
			grappleTight.startTracking(followpos);
			
			bInvisible = true;
			diff = level.vec3diff(fixedpos, followpos);
			if(diff ~== (0,0,0)) return;
			vector3 dir = diff.Unit();
			
			if(src == plr)
			{
				if(btns & BT_JUMP) 
				{
					plr.vel.z += 5;
					Retract();
					return;
				}
				if(haloplr) 
				{
					haloplr.fricmod = 1.0; 
					haloplr.aircontrol = 1.0;
				}
			}
			else
			{
				dir = -dir;
			}
			
			// Cancel on melee or if grapple is pressed again.
			if( (btns & HaloPlayer.BT_GRAPPLE) || (btns & BT_USER2) ) 
			{
				Retract();
				return;
			}
			
			// Spring physics
			spring_vel = -HaloMath.DampedSpring(dist, 0, 1, 0.0008, 1);
			
			// Acceleration
			src.gravity = 0;
			double addspd = clamp(spring_vel, 0, 80.0 / TICRATE);
			
			// Apply velocity
			//dir.z *= 0.8;
			src.vel += dir * addspd;
			plr.A_StartSound("Halo/Spartan/ZipLine/Loop", CHAN_7, CHANF_OVERLAP|CHANF_LOOPING);
			
			if(dist <= 96) 
			{
				if(src is "Inventory") src.Touch(plr);
				if(src is "WeaponPickupProxy") 
				{
					WeaponPickupProxy(src).forcepickup = true;
					lerp = 0;
				}	
				Retract();
			}
		}
	}
}

class RopeSegment : Segment
{
	Default
	{
		YScale 1;
		XScale 1.5;
		
		RenderStyle "Normal";
		Translation "0:255=@80[0,0,0]";
	}

	override vector3 GetEndOffs()
	{
		return (Scale.Y,0,0);
	}
}

class AimLineTracer : LineActivatorTracer
{
	play static AimLineTracer DoTrace(Actor src, double tangle, double tpitch, double dist, uint traceflags = 0)
	{
		AimLineTracer tracer = new("AimLineTracer");
		if(tracer) 
		{
			tracer.src = src;
			vector3 dir = HaloMath.VecFromAngles(tangle, tpitch);
			vector3 tracePos = src.pos;
			if(src.player) tracePos.z = src.player.viewz;
			tracer.Trace(tracePos, src.CurSector, dir, dist, traceflags);
		}
		return tracer;
	}
	
	override ETraceStatus TraceCallback()
	{
		if(results.HitType == Trace_HitWall)
		{
			let stat = HandleWall();
			return stat;
		}
		
		if(results.HitType == Trace_HitActor)
		{
			let hitAct = results.HitActor;
			
			if( hitAct == src || !hitAct.bSOLID && !(hitAct is "Inventory") && !(hitAct is "WeaponPickupProxy") ) 
			{
				results.HitActor = NULL;
				return Trace_Skip;
			}
		}
		
		return Trace_Stop;
	}
}