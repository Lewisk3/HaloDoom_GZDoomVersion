class Halo_FlamerFuel : Ammo 
{
	Default 
	{
		Inventory.MaxAmount 100;
	}
}

class HaloFlames : CheapActor
{
	double rollDir;
	
	Default
	{
		RenderStyle "Add";
		+BRIGHT;
		Speed 10;
		Scale 0.08;
		+ROLLSPRITE;
		+FLOAT;
		
		DamageType "Fire";
		Damage (1); // Damage per tic.
		Radius 8; 
		Height 8;
	}

	override void BeginPlay()
	{
		super.BeginPlay();
		
		roll = frandom[FlamerFX](-180,180);
		double scaleMod = frandom[FlamerFX](0.95,1.05);
		
		A_SetScale(
			default.Scale.X * scaleMod, 
			default.Scale.Y * scaleMod * randompick[FlamerFX](-1,1)
		);
		
		angle += frandom[FlamesWindFX](-0.12,0.12);
		pitch += frandom[FlamesWindFX](-0.09,0.09);
		rollDir = randompick[FlamerFX](-1,1);
	}

	override void Tick()
	{
		super.Tick();
		if(isFrozen()) return;
		
		vel = HaloMath.VecFromAngles(angle, pitch, Speed);
		if(target && GetAge() < 3) vel += target.vel;
		
		double shadeAlpha = HaloMath.Lerp(0, 3.0, GetAge() / 15.0);
		if(shadeAlpha < 1.0)
		{
			A_SetRenderStyle(alpha, STYLE_AddShaded);
			
			Color shadeCol = HLStatusColor.HSLtoRGB( 270 / 360.0, 1.0, 0.40); 
			SetShade(shadeCol);
		}
		else
			A_SetRenderStyle(alpha, STYLE_Add);
		
		// Check collision before moving.
		vector3 toPos = level.vec3offset(pos, vel);
		FCheckPosition posCheck;
		
		bool zCollsion = (toPos.z < floorz || toPos.z > ceilingz);
		if( !CheckMove(toPos.xy, PCM_NOACTORS, tm:posCheck) || zCollsion )
		{
			bool validate = true;
			Line ln = blockingLine;			
			
			if ( ln && (ln.flags & Line.ML_BLOCKMONSTERS) )
				validate = false;
			
			if(validate)
			{
				vel.xy *= 0;
				vel.z = zCollsion ? 0 : vel.z * 0.25;
				toPos = level.vec3offset(pos, vel);
			}
		}
		SetOrigin(toPos, true);
		
		angle += frandom[FlamesWindFX](-0.12,0.12);
		pitch += frandom[FlamesWindFX](-0.09,0.09);
		roll += frandom[FlamerFX](0.1,1.0) * rollDir;
		
		A_SetScale(
			Scale.X * 1.02, 
			Scale.Y * 1.02
		);
		alpha *= 0.98;
		
		// Actor collision checking
		let blockingIt = BlockThingsIterator.Create(self, 16);
		Actor victim;
		
		// Do not attack every frame.
		if( !(GetAge()%2) && GetAge() < 35)
		{
			while(blockingIt.Next())
			{
				victim = blockingIt.Thing;
				if(Distance3DSquared(victim) > 64*64) continue;
				if(!victim.bSHOOTABLE) continue;
				if(victim == target) continue;
				
				victim.DamageMobJ(self, target, Damage, damageType);
			}
		}
		if(alpha <= 0.1) Destroy();
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_Jump(255, random(0,10));
			XTH1 ABCDEFGHIJKLMNOPQRSTUVWXYZ 2;
			XTH2 ABCDEFGH 1;
			XTH2 IJKLMNOP 1
			{
				A_FadeOut(0.01);
				if( !(level.maptime%4) && !isFrozen() )
				{
					let smoke = Spawn("FlamerSmoke", pos);
					smoke.A_SetScale(Scale.X * 0.5, Scale.Y * 0.5);
					smoke.vel = vel * 0.35;
				}
			}
			XTH3 QRSTU 1;
			XTH2 V 1;
		wait;
	}
}

class FlamerSmoke : TankRocket_Smoke
{
	Default
	{	
		Scale 0.125;
	}
}


class WeldingBeamDecal : LaserBeamDecal
{
	Default
	{
		Translation "0:255=@64[223,89,48]";
		Scale 0.5;
	}
}

class LSR_WeldingBeam : LaserBeam
{
	uint healTics;
	Default
	{
		Alpha 2.0;
		Scale 1.0;
		LaserBeam.LaserColor "Orange"; 
		LaserBeam.TrackWeapon true, PSP_WEAPON;
		LaserBeam.AimFromWeapon false;
		LaserBeam.LaserDecal "WeldingBeamDecal";
		DamageType "Plasma";
		+BRIGHT;
	}
	
	bool flicker;
	
	override void BeamTick()
	{
		aimAtCrosshair();
		
		if(hitData.hitType != TRACE_HitNone) 
			OnImpact(hitData.HitLocation, hitData.hitActor);
			
		if( !(GetAge()%2) )
			flicker = !flicker; 
		
		alpha = flicker ? 0 : 1.0;
		
		if(healTics == 0) 
		{
			A_StopSound(CHAN_VOICE);
			A_StartSound("Halo/Weapons/Flamer/Weld/RepairEnd", CHAN_AUTO, CHANF_OVERLAP);
			healTics = -1;
		}
		else if(healTics)
			healTics--;
	}
	
	override void OnImpact(vector3 hitPos, Actor hitActor)
	{
		super.OnImpact(hitPos, hitActor);
		
		if(hitActor) 
		{	
			bool isVehicle = hitActor is "HaloVehicle";
			if(isVehicle && hitActor.health < hitActor.SpawnHealth()) 
			{
				A_StartSound("Halo/Weapons/Flamer/Weld/RepairLoop", CHAN_VOICE, CHANF_OVERLAP|CHANF_LOOPING);
				healTics = 2;
				hitActor.GiveBody(3);
			}
			else if(!isVehicle)
			{
				hitActor.DamageMobj(self, source, 1, DamageType);
			}
		}

		// Particles
		let emitter = Spawn("WeldingParticleEmitter", hitPos);
		if(emitter)
		{
			emitter.angle = angle;
			emitter.pitch = pitch;
		}
	}
}
class LSR_WeldingBeamCore : LSR_WeldingBeam
{
	Default
	{
		Alpha 2.0;
		Scale 0.35;
		LaserBeam.LaserColor "Yellow"; 
		LaserBeam.TrackWeapon true, PSP_WEAPON;
		LaserBeam.AimFromWeapon false;
		+BRIGHT;
	}
	
	override void OnImpact(vector3 hitPos, Actor hitActor) 
	{
		// startTracking(hitPos);
	}
}

class WeldingParticleEmitter : CheapActor
{
	virtual void DoParticles(int amt)
	{
		for(int i = 0; i < amt; i++)
		{
			// Particles
			double spawnAngle = (angle + 180) + frandom[SparksFX](-90,90);
			double spawnPitch = -pitch + frandom[SparksFX](-30,30);
			vector3 spawnVel = HaloMath.VecFromAngles(spawnAngle, spawnPitch, 6);
			spawnVel.z += frandom[SparksFX](-0.5,3);
			
			A_SpawnParticle( 
				0xFFE98630, SPF_FULLBRIGHT, TICRATE, 
				size:2.65, angle: spawnAngle, 0,0,0, 
				spawnVel.x, spawnVel.y, spawnVel.z, 
				0,0, -GetGravity(), 1.0, 0.02
			);
		}
	}
		
	States
	{
		Spawn:
			TNT1 A 1;
			TNT1 A 1 DoParticles( floor(3 * halodoom_effectintensity) );
		stop;
	}
}

class Halo_Flamethrower : HaloGun
{	
	int fireCounter;
	LaserBeam weldlaser, weldlaserCore;
	
	Default
	{
		//$Category "HaloDoom/Weapons"
		Weapon.SlotNumber 6;
		Obituary "%o was burnt to a crisp by %k's Flamethrower.";
		Inventory.PickupMessage	"Picked up the M6634 Flamethrower.";
		Tag "Flamethrower";
		Weapon.BobSpeed 1.32;
		Weapon.BobRangeX 0.50;
		Weapon.AmmoType1 "Halo_FlamerFuel";
		Weapon.AmmoType2 "Halo_FlamerFuel";
		Weapon.AmmoGive 50;
				
		// Recoil
		HaloGun.Bloom 0;
		HaloGun.BloomSpeed 1.0;
		HaloGun.BaseRecoil 0;
		HaloGun.Inaccuracy 0;
		HaloGun.Crosshair "FLMRet", 0.5;
		HaloGun.UIGraphic "WI_FLM", 0.75, 0.75;
		
		HaloGun.Availability "HL3, HL4, StarWars";
		HaloGun.PowerTier P_POWER;
		
		HaloGun.LowerOnMelee 200; // Lower off screen.
		
		RecoilWeapon.YOffsetRange -10, 40;
	}
		
	action void A_FireFlamer()
	{
		vector3 hitPos; Actor flame;
		[hitPos, flame] = A_ShootProjectile("HaloFlames", 16, -8);	
		if(flame)
		{
			let haloplr = HaloPlayer(self);
			// Idk why I have to manually set these here...
			A_SetSFXPos(25, 16, -8);
			flame.angle = angle;
			flame.pitch = pitch;
			
			if(haloplr)
			{
				vector3 aimAngles = level.SphericalCoords(invoker.sfx_pos, haloplr.aimPos, (angle, pitch)); 	
				flame.angle += aimAngles.x;
				flame.pitch -= aimAngles.y;
			}
			
			// Ignore self damage.
			flame.target = self;
		}
		
		//A_SetSFXPos(25,-10,-10);
		//A_SpawnSFX("MuzzleSmoke", 0,0);
		
		if( ((++invoker.fireCounter)%7) >= 6 )
			A_TakeAmmo();
	}
	
	action void A_StopFlames()
	{
		A_StopSound(CHAN_7);
		A_WeapSound("Halo/Weapons/Flamer/Fire/End");
	}
	
	action void A_BeginWelding()
	{
		A_WeapSound("Halo/Weapons/Flamer/Weld/Start", CHANF_OVERLAP);
		A_Light(2);
		
		if(!invoker.weldlaser)
		{
			invoker.weldlaser = LaserBeam.Create(self, 4, 1.8, -2, maxDist:256, type:"LSR_WeldingBeam");
			invoker.weldlaser.setEnabled(true);
			
			invoker.weldlaserCore = LaserBeam.Create(self, 4, 1.8, -2, maxDist:256, type:"LSR_WeldingBeamCore");
			invoker.weldlaserCore.setEnabled(true);
		}
		else
		{
			invoker.weldlaser.setEnabled(true);
			invoker.weldlaserCore.setEnabled(true);
		}
	}
	
	action void A_EndWelding(bool dosound = true)
	{
		A_StopSound(CHAN_7);
		if(dosound) A_WeapSound("Halo/Weapons/Flamer/Weld/End");
		A_Light(0);
		if(invoker.weldlaser)
		{
			invoker.weldlaser.setEnabled(false);
			invoker.weldlaserCore.setEnabled(false);
			invoker.weldlaser.A_StopSound(CHAN_FLAMEIDLE);
		}
	}
	
	const CHAN_FLAMEIDLE = 12;
	override void OnDropSwap()
	{
		Owner.A_StopSound(CHAN_FLAMEIDLE);
	}
	
	
	States
	{
		
		Ready:
			TNT1 A 0 A_WeapSound("Halo/Weapons/Flamer/Draw");
			WRS1 ABCDEFGHHHIJKLMNO 1 A_DoSelectAnim();
		Ready.Active:
			WRI1 A 1 
			{
				A_StopSound(CHAN_7);
				A_StartSound("Halo/Weapons/Flamer/IdleLoop", CHAN_FLAMEIDLE, CHANF_OVERLAP|CHANF_LOOPING);
				A_HaloWeaponReady(WRF_ALLOWRELOAD, usescope:false);
			}
		loop;
		
		Ready.Dryfire:
			WRI1 A 4 A_WeapSound("Halo/Weapons/DryFire", CHANF_OVERLAP);
		goto Ready.Active;

		Select:
			TNT1 A 1 A_GunRaise();
		wait;

		Deselect:
			WRS1 EDCB 1;
			WRS1 A 1 
			{
				A_StopSound(CHAN_7);
				A_StopSound(CHAN_FLAMEIDLE);
				A_GunLower();
			}
		wait;
				
		Fire:
			TNT1 A 0 A_JumpIf(!CountLoadedAmmo(), "Ready.Dryfire");
			WRF1 B 1 Bright 
			{
				A_StopFlames();
				A_WeapSound("Halo/Weapons/Flamer/Fire/Start", CHANF_OVERLAP);
				A_WeapSound("Fire/Ignite", CHANF_OVERLAP);
				A_FireFlamer();
			}
		Fire.Loop:
			TNT1 A 0 A_JumpIf(!CountLoadedAmmo(), "Fire.Stop");
			WRF1 CDEFGHI 1 Bright 
			{
				A_RollQuake(1,12,1);
				A_RQuakeEx(2,2,4,2,0,20,"",QF_RELATIVE|QF_WAVE);
				A_FireFlamer();
				A_StartSound("Halo/Weapons/Flamer/Fire/Loop", CHAN_7, CHANF_OVERLAP|CHANF_LOOPING);
				A_StartSound("Fire/BurnLoop", CHAN_7, CHANF_OVERLAP|CHANF_LOOPING);
				A_RecoilOffset(
					frandom[FlamerOffs](-0.65, 0.65), 
					frandom[FlamerOffs](-0.25, 0.05), 
					2, true
				);
			}
			WRF1 J 1 A_ReFire("Fire.Loop");
		Fire.Stop:
			TNT1 A 0 A_StopFlames();
			WRF1 KLMMMMM 1 A_RecoilOffset(0,0, 4);
		goto Ready.Active;
		
		AltFire:
			TNT1 A 0 A_JumpIf(!CountLoadedAmmo(), "Ready.Dryfire");
			WRW1 A 1 Bright A_BeginWelding();
		Weld.Loop:
			TNT1 A 0 A_JumpIf(!CountLoadedAmmo(), "Weld.Stop");
			TNT1 A 0 
			{
				A_StartSound("Halo/Weapons/Flamer/Weld/Loop", CHAN_7, CHANF_OVERLAP|CHANF_LOOPING);
				A_TakeAmmo();
			}
			WRW1 BCDEFG 2 Bright;
			WRW1 H 1 A_ReFire("Weld.Loop");
		Weld.Stop:
			WRW1 I 1;
			WRI1 A 1 A_EndWelding();
		goto Ready.Active;
		
		Spawn:
			WRG1 A -1;
		stop;
	}
}
