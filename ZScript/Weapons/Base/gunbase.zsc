class HaloGun : RecoilWeapon
{
	const BTN_SWITCHWEAP = BT_USER1;
	bool pbtn_fire;
	bool pbtn_altfire;
	bool backpack_reloading;
	uint backpack_reloadtimer;
	uint backpack_reloadmaxtime;
	double baserecoil;
	double spreadmod; // Spread introduced by continuous fire
	double bloomamt, bloomspd, accmod;
	double rotation_range;
	double rotation_sens;
	
	// UI Stuff
	string wcrosshair;
	string UI_Icon;
	
	Property Bloom : bloomamt;
	Property BloomSpeed : bloomspd;
	Property Crosshair : wcrosshair;
	Property BaseRecoil : baserecoil;
	Property Inaccuracy : accmod;
	Property SwayRange : rotation_range;
	Property SwaySpeed : rotation_sens;
	Property BackpackReloadTime : backpack_reloadmaxtime;
	property UIGraphic : UI_Icon;
	
	Default
	{
		RecoilWeapon.RecoilSpeed 16;
		HaloGun.Bloom 0.32;
		HaloGun.Crosshair "";
		HaloGun.BaseRecoil 2;
		HaloGun.BackpackReloadTime 35;
		HaloGun.UIGraphic "WI_AR";
		HaloGun.SwayRange 5.0;
		HaloGun.SwaySpeed 1.5;
	}
	
	// For some reason weapons start with an odd offset.
	action void A_DoSelectAnim()
	{
		 A_WeaponOffset(0, 45);
	}

	action void A_UpdateSpread()
	{
		invoker.spreadmod += invoker.bloomamt;
	}
	
	action double A_RecoilSpread()
	{
		return frandom[GunRecoil](-invoker.baserecoil, invoker.baserecoil)*(1.0+(invoker.spreadmod*invoker.accmod));
	}
	
	bool CheckWeaponSelected()
	{
		return (Owner.player && Owner.player.ReadyWeapon == self);
	}
	
	action void A_FollowRotation(int DEST_LAYER, int SRC_LAYER, double mul = 1.0)
	{
		let src_psp = player.GetPSprite(SRC_LAYER);
		A_OverlayPivotAlign(DEST_LAYER, PSPA_CENTER, PSPA_CENTER);
		A_OverlayRotate(DEST_LAYER, src_psp.rotation*mul);
	}
	action void A_FollowRotatedPos(int DEST_LAYER, int SRC_LAYER, vector2 max, double mul = 1.0)
	{
		let src_psp = player.GetPSprite(SRC_LAYER);
		vector2 rvec = (cos(src_psp.rotation+90)*max.x, sin(src_psp.rotation+90)*max.y) * mul;
		A_OverlayOffset(DEST_LAYER, rvec.x, rvec.y);
	}
	
	
	action void A_UpdateCrosshair(string nxhair)
	{
		if(nxhair == "") 
			invoker.wcrosshair = invoker.default.wcrosshair;
		else
			invoker.wcrosshair = nxhair;
	}
	
	action void A_CancelBackpackReload()
	{
		invoker.backpack_reloading = false;
		invoker.backpack_reloadtimer = 0;
	}
	
	action void A_SetSprite(Name spr, uint layer = PSP_WEAPON)
	{
		let spr = GetSpriteIndex(spr);
		if(!player) return;
		let psp = player.GetPSprite(layer);
		if(psp) psp.Sprite = spr;
	}
	action void A_SetFrame(int frm, uint layer = PSP_WEAPON)
	{
		if(!player) return;
		let psp = player.GetPSprite(layer);
		if(psp) psp.Frame = frm;
	}
	
	clearscope Weapon FindNextWeapon()
	{
		Weapon gun = NULL;
		if(!Owner) return NULL;
		for(let i = Owner.Inv; i; i = i.Inv)
		{
			gun = Weapon(i);
			if(gun && gun != self) break;
		}
		return gun;
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		if(!CheckWeaponSelected()) 
		{
			if(backpack_reloading)
			{
				backpack_reloadtimer--;
				if(backpack_reloadtimer <= 0)
				{
					let rammo = GetDefaultByType(AmmoType2);
					int reserves = countinv(AmmoType1);
					int takeammo = rammo.maxamount - countinv(AmmoType2); 
					if(takeammo > reserves) takeammo = reserves;
					GiveInventory(AmmoType2,takeammo);
					TakeInventory(AmmoType1,takeammo);
					backpack_reloading = false;
					backpack_reloadtimer = 0;
					// console.printf("Finished backpack reload");
				}
			}
			return;
		}
		if(!Owner.player) return;
		
		// Get useful data
		let btns = Owner.player.cmd.buttons;
		let psp  = Owner.player.GetPSprite(PSP_WEAPON);
			
		// Weapon roll
		vector2 su = (cos(Owner.angle+90), sin(Owner.angle+90));
		vector2 vu = Owner.vel.xy;
		vu.x *= su.x;
		vu.y *= su.y;
		psp.halign = PSPA_CENTER;
		psp.valign = PSPA_CENTER;
		double weaprotation = (vu.x+vu.y);
		if(Owner.player.cmd.sidemove && abs(weaprotation) > 0.02)
			psp.rotation = HaloMath.Lerp(psp.rotation, weaprotation * rotation_sens, 0.1);
		else
			psp.rotation = HaloMath.Lerp(psp.rotation, 0, 0.1);
			
		psp.rotation = clamp(psp.rotation, -rotation_range, rotation_range);
		
		// Process weapon switch
		bool inreload = psp && InStateSequence(psp.CurState,FindState("Reload"));
		if((btns & BTN_SWITCHWEAP) && psp && !InStateSequence(psp.CurState,FindState("Deselect.Quick")))
		{
			let nextweap = FindNextWeapon();
			if(nextweap) 
			{
				Owner.player.WeaponState |= WF_WEAPONSWITCHOK | WF_REFIRESWITCHOK;
				State tostate = !inreload ? FindState("Deselect") : FindState("Deselect.Quick");
				psp.SetState(tostate);
				nextweap.Use(false);
			}
		}
		// Backpack reload check
		if(inreload && A_ButtonPressed(BT_RELOAD, Owner) && !backpack_reloading)
		{
			if(backpack_reloadtimer)
				backpack_reloading = true;
			else
				backpack_reloadtimer = backpack_reloadmaxtime;
		}

		// Constantly keep track of this for better responsiveness.
		pbtn_fire = A_ButtonPressed(BT_ATTACK, Owner);
		pbtn_altfire = A_ButtonPressed(BT_ALTATTACK, Owner);
		
		spreadmod -= bloomamt*bloomspd;
		spreadmod = clamp(spreadmod, 0, 2);
	}
	
	// This override will ensure that the weapon is given its clip ammo upon 
	// being picked up.
	override bool TryPickup (in out Actor toucher)
	{
		if(!(toucher is "PlayerPawn")) return super.TryPickup(toucher);
		if(!toucher.FindInventory(getClassName())) 
		{
			if(AmmoType2)
			{
				let rammo = GetDefaultByType(AmmoType2);
				toucher.GiveInventory(AmmoType2,rammo.maxamount);
			}
		}
		return super.TryPickup(toucher);;
	}
	
	// [Lewisk3] Checks if a button was recently pressed.
	action bool A_ButtonPressed(int btn, Actor ptr=NULL)
	{
		let src = ptr ? ptr : self;
		if(!src.player) return false;
		return (src.player.cmd.buttons & btn) && !(src.player.oldbuttons & btn);
	}
	action bool A_FirePressed() { return invoker.pbtn_fire; }
	action bool A_AltFirePressed() { return invoker.pbtn_altfire; }
	
	// [Lewisk3] Use this instead of using deprecated functions :P
	action void A_WeapSound(sound snd, uint flags = 0)
	{
		A_StartSound(snd, CHAN_WEAPON, flags);
	}
	
	// For reloading clips/magazines
	action void A_ReloadClip()
	{
		let rammo = GetDefaultByType(invoker.AmmoType2);
		int reserves = countinv(invoker.AmmoType1);
		
		int takeammo = rammo.maxamount - countinv(invoker.AmmoType2); 
		if(takeammo > reserves) takeammo = reserves;
		
		GiveInventory(invoker.AmmoType2,takeammo);
		TakeInventory(invoker.AmmoType1,takeammo);
		A_CancelBackpackReload();
	}
	
	// Takes from primary ammunition pool, optionally has a type parameter
	// setting this to ammotype1 will take from the secondary pool. 
	// By default NULL results in using ammotype2
	action void A_TakeAmmo(int amt = 1, class<Inventory> type = NULL)
	{
		if(!type) type = invoker.ammotype2;
		A_TakeInventory(type, amt);
	}
	
	// For reloading one at a time, like a shotgun.
	action void A_ReloadSingle()
	{
		if(countinv(invoker.AmmoType1) > 0)
		{
			TakeInventory(invoker.AmmoType1,1);
			GiveInventory(invoker.AmmoType2,1);
			A_CancelBackpackReload();
		}
	}
	
	// Check if we need to reload, if we do, jump to Reload.
	action state A_GunCheckReload()
	{
		return !countinv(invoker.AmmoType2) ? ResolveState("Reload") : ResolveState(NULL);
	}
	
	// Validate that a reload should be done, returns fallback if mag is already full 
	// or if no reserve ammo is found.
	action state A_ValidateReload(StateLabel fallback="Ready")
	{
		let rammo = GetDefaultByType(invoker.AmmoType2);
		if(countinv(invoker.AmmoType2) == rammo.maxamount || countinv(invoker.AmmoType1) == 0)
			return ResolveState(fallback);
		return ResolveState(NULL);
	}
	
	States
	{
		Deselect.Quick:
			"####" "#" 1; 
			"####" "#" 0 
			{
				A_SetupLower();
				A_RLower(12);
			}
		loop;
	}
}
