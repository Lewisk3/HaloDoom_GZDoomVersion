class HaloProjectile : FastProjectile
{
	mixin HaloProjectile_Common;
	
	Default
	{
		Radius 3;
		Height 3;
		Speed 0;
		Projectile;
		+INTERPOLATEANGLES;
		+BLOODSPLATTER;
		DamageType "Bullet";
		
		HaloProjectile.SetRanges 61, 123;
		HaloProjectile.MinRangeDamage 40; 
		HaloProjectile.BaseDamage 145;
		HaloProjectile.Speed_MPS 914.0;
		HaloProjectile.RipperCount 0;
		HaloProjectile.ConvergeToAim true;
		HaloProjectile.HeadshotDMGFactor 1.0;
	}
	
	override int SpecialMissileHit(Actor victim)
	{	
		return Handle_MissileHit(victim);
	}
		
	override void PostBeginPlay()
	{
		Init();
		super.PostBeginPlay();
	}
	
	override void Tick()
	{		
		activateLines();
		super.Tick();
	
		if(target && GetAge() < 5) SetOrigin(Vec3Offset(target.vel.x,target.vel.y,target.vel.z), true);
		if(isHoming) Handle_Homing();
	}
}

class HaloSlowProjectile : Actor
{
	mixin HaloProjectile_Common;
	
	// Kabedon
	FLineTraceData pinData;
	vector3 pinPos;
	vector3 pinDir;
	Actor pinnedActor;
	double pinDist;
	int pinTime;

	Property SetupWallpinning : pinDist, pinTime; 

	Default
	{
		Radius 3;
		Height 3;
		Speed 0;
		Projectile;
		+INTERPOLATEANGLES;
		+BLOODSPLATTER;
		DamageType "Bullet";
		
		HaloSlowProjectile.SetRanges 0, 0;
		HaloSlowProjectile.MinRangeDamage 100; 
		HaloSlowProjectile.BaseDamage 10;
		HaloSlowProjectile.Speed_MPS 150.0;
		HaloSlowProjectile.RipperCount 0;
		HaloSlowProjectile.ConvergeToAim true;
		HaloSlowProjectile.HeadshotDMGFactor 1.0;
	}
			
	override void PostBeginPlay()
	{
		Init();
		super.PostBeginPlay();
	}
	
	override void Tick()
	{
		activateLines();
		super.Tick();
			
		if(target && GetAge() < 5) SetOrigin(Vec3Offset(target.vel.x,target.vel.y,target.vel.z), true);
		if(isHoming) Handle_Homing();
	}

	override int SpecialMissileHit(Actor victim)
	{
		// Victim is damaged by this function.
		int defaultHit = Handle_MissileHit(victim);
	
		// Check if pinned
		if( pinDist > 0 && pinTime > 0 && target && !victim.bNOBLOOD)
		{		
			vector2 aimAngles = (target.angle, target.pitch);
			LineTrace(aimAngles.x, pinDist, aimAngles.y, TRF_THRUACTORS, data:pinData);
			
			bool deadEnough = victim.health <= 0;
			if(pinData.HitLine && deadEnough)
			{
				victim.vel *= 0;
				pinDir = HaloMath.VecFromAngles(aimAngles.x + 180, aimAngles.y, victim.radius * 0.5);
				pinPos = level.vec3offset(pinData.hitLocation, pinDir);
				pinPos.z -= (pos.z - victim.pos.z);
				
				pinnedActor = victim;
				victim.DamageMobJ(target, self, victim.health, "wallpin");
				SetState(FindState("Pinned"));
			
				bSOLID = false;
				bMISSILE = false;
				vel *= 0;
				return 1;
			}
		}
		
		if(defaulthit != 1 && bMISSILE) 
		{
			vel *= 0;
			bMISSILE = false;
			SetState(FindState("Death"));
		}
		return defaultHit;
	}
	
	States
	{
		Spawn:	
			TRAC A 1 Bright;
		loop;
	
		Pinned:
 			"####" "#" 1
			{
				if(pinnedActor) 
				{
					SetOrigin(level.vec3offset(pinData.HitLocation, pinDir), true);
					pinnedActor.SetOrigin(pinPos, true);
					
					pinnedActor.bNOGRAVITY = true;
					pinnedActor.vel *= 0;
					
					pinnedActor.tics = -1;
				}
			}
			"####" "#" 0 A_JumpIf(!(pinTime--), "Pinned.Finish");
		loop;
		
		Pinned.Finish:
			TNT1 A 1
			{
				// Restore pinned actors flags.
				if(pinnedActor)
				{
					pinnedActor.A_SetSize(8, 8);
					pinnedActor.tics = 1;
					pinnedActor.bNOGRAVITY = false;
				}
			}
		stop;
	}
}

class NeedleCounter : Inventory
{
	Array<HaloNeedleProjectile> needles;
	default
	{
		inventory.maxamount 1;
	}
	int CountNeedles()
	{
		return needles.Size();
	}
	void AddNeedle(HaloNeedleProjectile needle)
	{
		needles.Push(needle);
	}
	void RemoveNeedle(HaloNeedleProjectile needle)
	{
		for(int i = 0; i < needles.Size(); i++)
		{
			if(needles[i] == needle) 
			{
				needles.Delete(i);
				break;
			}
		}
	}
	void ExplodeNeedles()
	{
		for(int i = needles.Size()-1; i >= 0; i--)	
			if(needles[i]) needles[i].doexplode = true;
	}
}
class HaloNeedleProjectile : HaloSlowProjectile
{
	double shatterdmg;
	bool doexplode;
	vector3 hitoffs;
	vector3 hitrelpos;
	double hitangle;
	double hitpitch;
	double maxhomdist;
	double homTurnMax;
	int explodetimer, explodedelay, explodecount;
	NeedleCounter needlecount;
	Property ExplodeDelay : explodedelay;
	Property ExplodeCount : explodecount;
	Property NeedleDamages : truedamage, shatterdmg;
	Property NeedleHoming : homTurnMax, homingStrength, homingFOV;
	Property NeedleHomRange : maxhomdist;

	Default
	{
		Radius 2;
		Height 5;
		Projectile;
		// Speed 40; Don't increase speed, otherwise they can bounce through walls.
		BounceType "Doom";
		BounceCount 4;
		RenderStyle "Add";
		+INTERPOLATEANGLES;
		+BOUNCEONWALLS;
		+BOUNCEONFLOORS;
		+BOUNCEONCEILINGS;
		-BOUNCEONACTORS;
		+SEEKERMISSILE;
		+SCREENSEEKER;
		+BLOODSPLATTER;
		Scale 0.25;
		HaloSlowProjectile.Speed_MPS 33;
		HaloNeedleProjectile.NeedleDamages 2, 10;
		HaloNeedleProjectile.ExplodeDelay 35; // 1 second.
		HaloNeedleProjectile.ExplodeCount 7; 
		HaloNeedleProjectile.NeedleHoming 40, 0.15, 30;
		HaloNeedleProjectile.NeedleHomRange 61;
		Translation "0:255=@70[128, 17, 247]";
	}
	
	override int SpecialMissileHit(Actor victim)
	{
		int defaultHit = Handle_MissileHit(victim);
		if(defaultHit == 1 || !victim || victim.health <= 0) return 1; // Ignore invalid actors.
		
		hitactor = victim;
		bSOLID = false;
		bMISSILE = false;
		vel *= 0;

		hitoffs = HaloMath.DiffToLocal(pos, victim.pos, (victim.angle, victim.pitch));
		hitangle = angle-victim.angle;
		hitpitch = pitch-victim.pitch;

		explodetimer = explodedelay;
		needlecount = NeedleCounter(victim.FindInventory("NeedleCounter"));
		if(!needlecount && target) 
		{
			victim.GiveInventory("NeedleCounter", 1);
			needlecount = NeedleCounter(victim.FindInventory("NeedleCounter"));
		}
		if(needlecount) needlecount.AddNeedle(self);
		SetState(ResolveState("Spawn.HitActor"));
		
		return 1;
	}
	
	override void Tick()
	{
		activateLines();
		super.Tick();
		
		if(hitactor)
		{
			vector3 followPos = HaloMath.V3Offset(hitactor.angle, hitactor.pitch, hitactor.roll, hitoffs.x * 0.25, hitoffs.y * 0.75, hitoffs.z, 1.0);
			followPos = level.Vec3Offset(hitactor.pos, followPos);

			angle = hitactor.angle+hitangle;
			pitch = hitactor.pitch+hitpitch;
			SetOrigin(followPos, true);
		}
		else if(getTravelDistance() < maxhomdist) // Do homing
		{
			Handle_Homing(homTurnMax);
		}
		
		if(GetAge() > 35*3)
		{
			vel *= 0;
			SetState(FindState("Death.Explode"));
		}
	}
		
	States
	{
		Spawn:	
			TRAC A 2 Bright 
			{
				SmokeTrail.Start("Purple", pos, pos - (vel * 5), (-angle, -pitch), 0.5);
			}
		loop;
		Spawn.HitActor:
			TRAC A 1 Bright 
			{
				StateLabel finalst = Null;
				explodetimer--;
				if(hitactor && hitactor.health <= 0 && needlecount) 
					hitactor.RemoveInventory(needlecount); 
				
				if(doexplode) finalst = "Death.Explode";
				if(!bMISSILE && (!hitactor || hitactor.health <= 0) || explodetimer <= 0) 
					finalst = "Death.Explode";
				return ResolveState(finalst);
			}
		loop;
		Death.Explode:
			TRAC A 1 
			{
				if((needlecount && needlecount.CountNeedles() >= explodecount) && !doexplode && hitactor) 
				{
					vector3 explodePos = hitactor.pos + (0,0,hitactor.height*0.5);
					Spawn("NeedleExplosion_Flare", explodePos);
					Spawn("NeedleExplosion", explodePos);
					A_StartSound("Halo/Weapons/Needler/SuperCombine", flags:CHANF_OVERLAP);
					
					for(int i = 0; i < 100; i++) 
					{
						double ang = frandom(0,360);
						double pit = frandom(-45,45);
						vector3 rdir = (
							cos(ang),
							sin(ang),
							-sin(pit)
						) * frandom(20,35);
						
						A_SpawnParticle(
							"Purple", SPF_FULLBRIGHT, 20, 10.0, ang,
							0,0, hitactor.height*0.5, rdir.x,rdir.y,rdir.z,0,0,0,
							frandom(0.5,1.0), 0.0125
						);
					}
					
					needlecount.ExplodeNeedles();
					hitactor.DamageMobJ(self, self.target, shatterdmg * explodecount, "Explosive", 0, angle);
					A_Explode(128,200,0);
				}
				
				if(hitactor) hitactor.DamageMobJ(self, self.target, shatterdmg, "Explosive", 0, angle);
				if(needlecount) needlecount.RemoveNeedle(self);
				Spawn("NeedleMiniExplosion", pos);
				
				for(int i = 0; i < 10; i++) 
				{
					A_SpawnParticle(
						"Purple", SPF_FULLBRIGHT|SPF_RELVEL,
						 35,5,
						 angle+frandom(-90,90), 
						 frandom(-20,20),frandom(-20,20),frandom(-10,10),
						 10,10,frandom(-8,8),0,0,-0.1,1.0,0.14,0.15);
				}
			}
		stop;
	}
}

class NeedleExplosion_Flare : TankRocket_Flare
{
	Default
	{
		Scale 0.75;
		RenderStyle "AddShaded";
		Alpha 1.0;
	}
	
	override void BeginPlay()
	{
		super.BeginPlay();
		SetShade(0xD6F843FF);
	}
}
class NeedleExplosion : FastActor
{
	Default
	{
		Scale 1.0;
		Alpha 1.0;
		RenderStyle "Add";
		//Translation "0:255=@60[248, 67, 255]";
	}
		
	States
	{
		Spawn:
			FX58 ABCDEFGHIJKLMNOPQ 1 Bright;
		stop;
	}
}
class NeedleMiniExplosion : NeedleExplosion
{
	Default
	{
		Scale 0.25;
		Translation "0:255=@60[248, 67, 255]";
	}
}

class HaloBullet : HaloProjectile
{
	Default
	{
		Radius 1;
		Height 1;
		Speed 100;
		RenderStyle "Add";
		+INTERPOLATEANGLES;
		+BLOODSPLATTER
		Decal "BulletHitDecal";
		Scale 0.5;
	}
		
	States
	{
		Spawn:	
			TRAC A 1 Bright;
		loop;
		Death:
			TNT1 A 0 
			{
				if(!hitactor) 
				{
					HaloMath.ParticlesFX(self, 0xFFfaf611,15,2,10);
					Spawn("MuzzleSmoke", pos);
				}
			}
		stop;
	}
}

// Railgun Beam
class RailgunProjectile : FastProjectile
{
	Actor source;
	double biridist;
	double aimdist;
	double expdmg;
	vector3 startpos;
	vector3 endpos;
	vector3 posoffs;
	vector3 dir;
	double railScale;
	
	// Keep track of ripped-through targets so damage isn't done multiple times.
	int ripamount;
	Array<Actor> act_hits;
	Property RipperCount : ripamount;
	
	Default
	{
		Radius 10;
		Height 10;
		RailgunProjectile.RipperCount 10;
		Speed STANCHION_BMPS;
		Projectile;
	}
	
	override int SpecialMissileHit(Actor victim)
	{
		// Ripped through actors only take damage once.
		if(act_hits.Find(victim) != act_hits.Size()) return 1;
	
		victim.DamageMobj(source, self, damage, "Railgun", DMG_THRUSTLESS, angle);
		A_Explode(expdmg * 0.25, expdmg * 0.05, 0);
		act_hits.Push(victim);	
		victim.BloodSplatter(pos, angle, true);
		
		let shock = Spawn("Railgun_Shockwave", pos);
		if(shock) 
		{
			shock.SetShade(0xFFfc9d03);
			shock.A_SetScale(0.05);
		}
		
		double inertia = HaloMath.GetInertia(victim.mass);
		inertia = clamp(inertia, 0.5, 2.0);
		victim.Thrust(20*inertia, angle);
		victim.vel.z += 10*inertia;
		
		// Rip through actors
		if(victim.health > 0) return 0; // Do not rip through bosses.
		if(ripamount > 0) 
		{
			ripamount--;
			return 1;
		}
		return 0;
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if(other == source) return false;
		return super.CanCollideWith(other, passive);
	}
	
	static RailgunProjectile FireRailgun(Actor source, double dmg, double expdmg, vector3 offs, double size = 1.0, vector2 viewoffs = (0,0), bool doShockwave = true, vector3 colors = (0xFFFF0000, 0xFFfc9d03, 0xFFFFFFFF))
	{
		vector3 spawnpos = HaloMath.RelativeV3Offset(source, 0,0,0, offs.x, offs.y, offs.z, 1.);
		let proj = RailgunProjectile(Actor.Spawn("RailgunProjectile", spawnpos));
		if(proj)
		{
			proj.angle = source.angle+viewoffs.x;
			proj.pitch = source.pitch+viewoffs.y;
			proj.startpos = spawnpos;
			proj.posoffs = offs;
			proj.source = source;
			proj.target = source;
			
			double cosp = cos(proj.pitch);
			proj.vel = (
				cos(proj.angle) * cosp,
				sin(proj.angle) * cosp,
				-sin(proj.pitch)
			) * ((proj.default.speed / 35) * UNIT_METER);
			proj.dir = proj.vel.Unit();

			double trueDamage = source.GetModifiedDamage("Railgun", dmg, false, proj, source);
			let lt = RailTracer.RailTrace(source, proj.angle, proj.pitch, 4096*4096, proj.default.ripamount, trueDamage + expdmg, traceFlags:0);

			//FLineTraceData lt;
			//proj.LineTrace(proj.angle, int.max, proj.pitch, TRF_THRUACTORS, offsetforward:source.radius+16, data:lt);
			vector3 hitpos = lt.results.HitPos;
			proj.endpos = hitpos;
			proj.aimdist = lt.results.Distance;			
		
			proj.SetDamage(trueDamage);
			proj.expdmg = expdmg;
			proj.railScale = size;
			
			let muzexp = Spawn("Railgun_MuzzleExplosion", proj.pos);
			if(muzexp) muzexp.A_SetScale(min(muzexp.default.Scale.X * 2., size));
			
			// Outer-most trail
			let smok = SmokeTrail.Start(int(colors.x), spawnpos, hitpos, (proj.angle, proj.pitch), 0.5, type:"RailgunTrail");
			if(smok)
			{
				smok.A_SetScale(15.0 * 0.7 * size);
			}
			
			// Outer trail
			smok = SmokeTrail.Start(int(colors.y), spawnpos, hitpos, (proj.angle, proj.pitch), 1.0, type:"RailgunTrail");
			if(smok)
			{
				smok.A_SetScale(10.0 * 0.7 * size);
			}
			
			// Inner trail
			smok = SmokeTrail.Start(int(colors.z), spawnpos, hitpos, (proj.angle, proj.pitch), 3.0);
			if(smok)
			{
				smok.A_SetScale(5.0 * 0.7 * size);
			}
			
			// Shockwave
			if(doShockwave) proj.Shockwave(0.2 * size, 0, 0xFF313de8); 
			proj.Biri(min(12, 10 * size), min(200, 200 * size), 0);
			
			//proj.Shockwave(0.1, 0.1);
			//proj.Biri(5, 100, 0.1);
			
			//proj.Shockwave(0.05, 0.25);
			//proj.Biri(5, 75, 0.25);
		}
		return proj;
	}
	
	void Shockwave(double scale, double dist = 0.10, Color col = 0xFFfc9d03)
	{
		vector3 forward = HaloMath.V3Offset(angle, pitch, roll, 40, 0,0, 1.);
		forward = level.vec3offset(forward, startpos);
		vector3 shockpos = level.vec3offset(forward, dir * (aimdist * dist));
		let shock = Spawn("Railgun_Shockwave", shockpos);
		Spawn("FX_Shockwave", pos);
		if(shock) 
		{
			shock.SetShade(col);
			shock.A_SetScale(scale);
		}
	}
	
	void Biri(double amt = 5, double dist = 50, double fixed_dist = -1)
	{
		double ang = angle+180;
		biridist = fixed_dist >= 0 ? fixed_dist : frandom(0, 1.0);
		int adjustedAmt = max(5 * halodoom_effectintensity, 0);
		for(int i = 0; i < amt; i++)
		{
			vector3 biripos = level.vec3offset(startpos, dir * (aimdist * biridist));
			BiriBiri.DoLightning(biripos, (ang + frandom(-60,60), 0), dist:dist, 1.0, 10.0, 5, 200);
			if(fixed_dist < 0) biridist += frandom(-0.05, 0.05);
			biripos.z -= 10;
			Spawn("LightningLight", biripos);
			if(i == 0) Spawn("LightSmoke", biripos);
		}
	}
	
	override void Tick()
	{
		super.Tick();
		if (isFrozen()) return;
		Biri(min(3, floor(3 * railScale)));
	}
	
	States
	{
		Cache:
			LITA A 1;
		stop;
		
		Spawn:
			TNT1 A 1;
		loop;
		
		Crash:
		XDeath:
		Death:
			TNT1 A 0 
			{
				let expl = Spawn("Railgun_Explosion", pos);
				if(expl) expl.A_SetScale(railScale * expl.default.Scale.X);
				A_Explode(expdmg, expdmg, 0);
			}
		Death.FadeOut:
			"####" A 1 
			{
				bool blink = random(0,1);
				if(blink) 
					sprite = GetSpriteIndex("LITA");
				else
					sprite = GetSpriteIndex("TNT1");
	
				A_FadeOut(0.02);
				if(GetAge()%5 == 0)
				{
					for(int i = 0; i < 2; i++)
						BiriBiri.DoLightning(pos, (angle+frandom(-45, 45)+180, frandom(-90,90)), dist:80*railScale, 1.0, 6.0, 5, 100);
				}
			}
		wait;
	}
}

class RailgunTrail : SmokeTrail
{
	Default
	{
		RenderStyle "AddShaded";
	}
	
	States
	{
		Spawn:
			BEAM A 10 Bright;
		Spawn.Loop:
			BEAM A 1 Bright A_FadeOut(0.02);
		loop;
	}
}

class Railgun_Shockwave : FastActor
{
	Default
	{
		RenderStyle "AddShaded";
		Scale 0.25;
	}
	
	override void Tick()
	{
		super.Tick();
		if(isFrozen()) return;
		
		A_SetScale(Scale.X + 0.008);
	}
	
	States
	{
		Spawn:
			BSW0 A 4 Bright;
			BSW0 A 1 Bright A_FadeOut(0.05);
		wait;
	}
}

class Railgun_Explosion : FastActor
{
	Default
	{
		Scale 1.75;
	}
	
	States
	{
		Spawn:
			TNT1 A 0;
			TNT1 A 1
			{
				A_StartSound("Halo/Scorpion/MissileExplosion", flags:CHANF_OVERLAP, attenuation: 0.1);
				let sprks = Spawn("ImpactSparks", pos);
				sprks.A_SetScale(scale.x / 1.75);
			}
			SX04 A 1 Bright
			{	
				let flare = Spawn("TankRocket_Flare", pos);
				if(flare) 
				{
					// flare.A_SetRenderStyle(1.0, STYLE_AddShaded);
					// flare.SetShade(0xFF313de8);
					flare.A_SetScale(0.5 * (scale.x / 1.75));
				}
				
				// Flying explosions
				double adjustedAmt = max(random[railExplode](15,30) * halodoom_effectintensity, 0);
				for(int i = 0; i < adjustedAmt; i++)
				{
					double spawnang = frandom(0,180);
					double spawndist = frandom(-10, 10);
					vector3 spawndir = (
						cos(angle + spawnang),
						sin(angle + spawnang),
						0
					) * spawndist;
					
					spawndir.z = frandom(-30,30);
					let expl = Spawn("TankRocket_FlyingExplosion", level.vec3offset(pos, spawndir));
					if(expl)
					{
						expl.A_SetScale(0.2 * (scale.x / 1.75));
						double velang = frandom(-180,180);
						vector3 veldir = (
							cos(velang),
							sin(velang),
							sin(frandom(-45,45)) * 1.5
						);
						expl.vel = veldir * 10;
					}
				}
			}
			SX04 BCDEFGHIJKLMNOPQ 1 Bright;
		stop;
	}
}

class Railgun_MuzzleExplosion : FastActor
{
	Default
	{
		+ROLLSPRITE;
		Scale 0.5;
	}
	
	States
	{
		Spawn:	
			TNT1 A 0;
			FX58 A 1 Bright
			{
				let flare = Spawn("TankRocket_Flare", pos);
				if(flare) flare.A_SetScale(0.25);				
			}
			FX58 AAABCDEFGHIJKLMNOP 2 Bright
			{
				roll += 0.01;
				A_FadeOut(0.005);
			}
			FX58 Q 1 Bright A_FadeOut(0.05);
		stop;
	}
}

class RailTracer : LineActivatorTracer
{
	int ripamt;
	double raildmg;
		
	static RailTracer RailTrace(Actor src, double tangle, double tpitch, double dist, int ripamount, double dmg, uint traceflags = 0)
	{
		let tracer = new("RailTracer");
		if(tracer) 
		{
			tracer.src = src;
			tracer.ripamt = ripamount;
			tracer.raildmg = dmg;
			
			let angles = Quat.FromAngles(tangle, tpitch, src.roll);
			vector3 dir = angles * (1.0,0,0);
			vector3 tracePos = level.vec3offset(src.pos, angles * (src.radius+16,0,0));
			if(src.player) tracePos.z = src.player.viewz;
			tracer.Trace(tracePos, src.CurSector, dir, dist, traceflags);
		}
		return tracer;
	}
		
	override ETraceStatus TraceCallback()
	{
		if(results.HitType == Trace_HitWall)
			return HandleWall();
		
		if(results.HitType == Trace_HitFloor || results.HitType == Trace_HitCeiling)
			return Trace_Stop;
		
		if(results.HitType == Trace_HitActor)
		{
			let hitAct = results.HitActor;
			if(hitAct == src || !hitAct.bSOLID && !hitAct.bSHOOTABLE) 
				return Trace_Skip;

			if( ripamt-- > 0 && hitAct && (hitAct.health - raildmg) <= 0 )
				return Trace_Skip;
			else 
				return Trace_Stop;
		}
		return Trace_Stop;
	}
}