class HaloProjectile : FastProjectile
{
	double truedamage;
	double range_falloff;
	double range_max;
	double falloff_minimum;
	vector3 spawnpos;
	
	Property SetRanges : range_falloff, range_max;
	Property MinRangeDamage : falloff_minimum;
	Property BaseDamage : truedamage;
	
	Default
	{
		Radius 5;
		Height 5;
		Speed 60;
		Projectile;
		+INTERPOLATEANGLES;
		
		HaloProjectile.SetRanges 61, 123;
		HaloProjectile.MinRangeDamage 0.4; 
		HaloProjectile.BaseDamage 145;
	}
	
	override int SpecialMissileHit(Actor victim)
	{	
		if(victim == target) return 1;
		AdjustRangeDamage();
		//console.printf("Damage output: %f, Dist: %f", truedamage, getTravelDistance());
		victim.DamageMobJ(target,self,truedamage,DamageType,0,angle);
		class<Actor> blud = victim.GetBloodType(0);
		if(blud && bBLOODSPLATTER && victim.bISMONSTER) victim.Spawn(blud,pos);
		return -1;
	}
	
	double getTravelDistance(bool tometers = true)
	{
		double convert = tometers ? UNIT_METER : 1.0;
		return clamp(HaloMath.Distance3D(pos, spawnpos),1,int.max) / convert;
	}	
	virtual void AdjustRangeDamage()
	{
		// Do not calculate damage if we have no ranged damage.
		if(range_max <= 0) return;
		// Interpolate to minimum damage based on range maximum.
		double dist = getTravelDistance();
		// Negate damage at max range.
		if(dist >= range_max)
		{
			truedamage = 0;
			return;
		}
		// Dampen damage until minimum.
		if(dist >= range_falloff)
		{
			double distmax = dist/range_max;
			double dmgmod = (-1.5 * (distmax**2)) + 1;
			dmgmod = clamp(dmgmod, falloff_minimum, 1.0);
			truedamage = default.truedamage*dmgmod;
		}
	}
	virtual void Init()
	{
		spawnpos = pos;
		SetDamage(0);
	}
	
	override void PostBeginPlay()
	{
		Init();
		super.PostBeginPlay();
	}
	override void Tick()
	{
		super.Tick();
		if(target) SetOrigin(pos+target.vel, true);
	}
}

class HaloBullet : HaloProjectile
{
	Default
	{
		Radius 1;
		Height 1;
		Speed 100;
		RenderStyle "Add";
		+INTERPOLATEANGLES;
		+BLOODSPLATTER
		
		Decal "BulletChip";
		Scale 0.5;
	}
	
	States
	{
		Spawn:	
			TRAC A 1 Bright;
		loop;
	}
}