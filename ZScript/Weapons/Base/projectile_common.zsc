mixin class HaloProjectile_Common
{
	double meterspeed;
	double truedamage;
	double range_falloff;
	double range_max;
	double falloff_minimum;
	double headshot_multiplier;
	double explode_dmg;
	double explode_radius;
	double rip_dmgmod;
	double rip_falloff;
	bool do_converge;
	vector3 spawnpos;
	Actor hitactor;
	int ripamount;
	bool isHoming;
	double homingStrength;
	
	// Shield stuff
	double shield_HeadshotDMG;
	double shield_DamageMod;
	
	// Keep track of ripped-through targets so damage isn't done multiple times.
	Array<Actor> act_hits;
	
	Property SetRanges : range_falloff, range_max;
	Property MinRangeDamage : falloff_minimum;
	Property BaseDamage : truedamage;
	Property Speed_MPS : meterspeed;
	Property RipperCount : ripamount;
	Property RipperDamageFalloff : rip_falloff;
	Property ConvergeToAim : do_converge;
	Property HeadshotDMGFactor : headshot_multiplier;
	Property DoExplosiveDamage : explode_dmg, explode_radius;
	Property SetupHoming : isHoming, homingStrength;
	Property ShieldDamageFactors :  shield_DamageMod, shield_HeadshotDMG;
		
	static double ApplyShieldDamage(double dmg, HaloProjectile proj, bool isHeadshot = false)
	{
		if(!proj) return dmg;
		if(proj.shield_DamageMod > 0   && !isHeadshot) dmg *= proj.shield_DamageMod;
		if(proj.shield_HeadshotDMG > 0 &&  isHeadshot) dmg *= proj.shield_HeadshotDMG;
		
		return dmg;
	}
	
	virtual void Handle_Homing()
	{
		// Find nearest viable target, track target.
		if(tracer)
		{
			vector3 dest = (tracer.pos.xy, tracer.pos.z+(tracer.height*0.5));
			vector3 trackingAngles = level.SphericalCoords(pos, dest, (angle, pitch));
			A_SetAngle(angle - (trackingAngles.x * homingStrength), SPF_INTERPOLATE);
			A_SetPitch(pitch - (trackingAngles.y * homingStrength), SPF_INTERPOLATE);
			
			// Update velocity
			vector3 newVel = HaloMath.V3Offset(angle, pitch, roll, 1.0,0,0, vel.Length());
			vel = newVel;
		}
		else
		{
			let it = ThinkerIterator.Create();
			Actor act;
			int mindist = int.max;
			while(act = Actor(it.Next()))
			{
				LookExParams look;
				look.FOV = 30;
				if(act == target) continue;
				if(!act.bSHOOTABLE || act.bCORPSE) continue;
				if(target && !target.IsVisible(act, false, look)) continue;
				int dist = Distance3DSquared(act);
				if(dist < mindist) 
				{
					tracer = act;
					mindist = dist;
				}
			}
		}
	}
	
	virtual int Handle_MissileHit(Actor victim)
	{
		// Skip these victims
		if(victim == target || !victim.bSHOOTABLE) return 1;
				
		// Ripped through actors only take damage once.
		if(act_hits.Find(victim) != act_hits.Size()) return 1;
		
		// Determine if victim is vehicle we're the driver of
		if(target)
		{
			let curveh = Veh_Manager(target.FindInventory("Veh_Manager"));
			if(curveh && curveh.veh == victim) return 1;
		}
		hitactor = victim;
		
		// Adjust Damage
		AdjustRangeDamage();
		double scaled_damage = truedamage * GAMEPLAY_DAMAGEMOD * (1.0-rip_dmgmod);
		bool headshot = HaloMath.CheckHeadshot(self, victim);
		if(headshot) scaled_damage *= headshot_multiplier;
		
		// Damage Victim
		Name dmgType = headshot ? 'Headshot' : DamageType;
	//	scaled_damage = target.GetModifiedDamage(dmgType, scaled_damage, false, self, target);
		
		victim.DamageMobJ(self, target, ceil(scaled_damage), dmgType, 0, angle);
		if(explode_dmg > 0) A_Explode(explode_dmg, explode_radius, 0);

		// Spawn Blood
		class<Actor> blud = victim.GetBloodType(0);
		if(blud && bBLOODSPLATTER && victim.bISMONSTER) victim.Spawn(blud,pos);
	
		// Rip through actors
		act_hits.Push(victim);
		if(ripamount > 0) 
		{
			ripamount--;
			rip_dmgmod += rip_falloff;
			rip_dmgmod = clamp(rip_dmgmod, 0, 1.0); 
			return 1;
		}
		
		return -1;
	}
	
	virtual void DoConverge(vector3 aimpos, vector2 offs)
	{
		// Do not follow crosshair converge for vehicles
		let curveh = Veh_Manager(target.FindInventory("Veh_Manager"));
		if(curveh) return;
		
		// Converge
		if(do_converge)
		{
			vector3 toaim = level.SphericalCoords(pos, aimpos, (angle-offs.x, pitch-offs.y));
			angle -= toaim.x;
			pitch -= toaim.y;
		}
		else
		{
			angle -= offs.x;
			pitch -= offs.y;
		}
	}
	
	virtual double getTravelDistance(bool tometers = true)
	{
		double convert = tometers ? UNIT_METER : 1.0;
		return clamp(HaloMath.Distance3D(pos, spawnpos),1,int.max) / convert;
	}	
	
	virtual void AdjustRangeDamage()
	{
		// Do not calculate damage if we have no ranged damage.
		if(range_max <= 0) return;
		// Interpolate to minimum damage based on range maximum.
		double dist = getTravelDistance();
		// Negate damage at max range.
		if(dist >= range_max)
		{
			// Destroy bullet so feedback is better,
			// we wont get hit markers at above max range.
			Destroy(); 
			return;
		}
		
		// Dampen damage until minimum.
		if(dist >= range_falloff && range_falloff > 0)
		{
			double distmax = dist/range_max;
			double dmgmod = (-1.5 * (distmax**2)) + 1;
			dmgmod = clamp(dmgmod, falloff_minimum/100., 1.0);
			truedamage = default.truedamage*dmgmod;
		}
	}
	
	virtual void Init()
	{
		spawnpos = pos;
		A_SetSpeed((meterspeed / 35.)*UNIT_METER);
		
		// Re-calculate velocity with new speed.
		double cosp = cos(pitch);
		vel = (
			cos(angle) * cosp,
			sin(angle) * cosp,
			-sin(pitch)
		) * speed;
		
		SetDamage(0);
	}
}