mixin class HaloProjectile_Common
{
	double meterspeed;
	double truedamage;
	double range_falloff;
	double range_max;
	double falloff_minimum;
	double headshot_multiplier;
	double explode_dmg;
	double explode_radius;
	double rip_dmgmod;
	double rip_falloff;
	double damageMult; // Must be greater than 1
	bool do_converge;
	vector3 spawnpos;
	Actor hitactor;
	int ripamount;
	bool isHoming;
	double homingStrength;
	double homingFOV;
	class<Actor> splashSpawner;
	
	// Shield stuff
	double shield_HeadshotDMG;
	double shield_DamageMod;
	
	// Keep track of ripped-through targets so damage isn't done multiple times.
	Array<Actor> act_hits;
	
	Property SplashSpawner : splashSpawner;
	Property SetRanges : range_falloff, range_max;
	Property MinRangeDamage : falloff_minimum;
	Property BaseDamage : truedamage;
	Property Speed_MPS : meterspeed;
	Property RipperCount : ripamount;
	Property RipperDamageFalloff : rip_falloff;
	Property ConvergeToAim : do_converge;
	Property HeadshotDMGFactor : headshot_multiplier;
	Property DoExplosiveDamage : explode_dmg, explode_radius;
	Property SetupHoming : isHoming, homingStrength, homingFOV;
	Property ShieldDamageFactors :  shield_DamageMod, shield_HeadshotDMG;
		
	static double ApplyShieldDamage(double dmg, Actor proj, bool isHeadshot = false)
	{
		let haloFastProj = HaloProjectile(proj);
		let haloSlowProj = HaloSlowProjectile(proj);
		
		// Ugh, man this is ugly...
		if(haloFastProj)
		{
			if(haloFastProj.shield_DamageMod > 0   && !isHeadshot) dmg *= haloFastProj.shield_DamageMod;
			if(haloFastProj.shield_HeadshotDMG > 0 &&  isHeadshot) dmg *= haloFastProj.shield_HeadshotDMG;
		}
		else if(haloSlowProj)
		{
			if(haloSlowProj.shield_DamageMod > 0   && !isHeadshot) dmg *= haloSlowProj.shield_DamageMod;
			if(haloSlowProj.shield_HeadshotDMG > 0 &&  isHeadshot) dmg *= haloSlowProj.shield_HeadshotDMG;
		}
		
		return dmg;
	}
	
	virtual void SpawnSplash()
	{
		let splash = Actor.Spawn(splashSpawner, (pos.x, pos.y, floorz));
		if(splash) splash.target = self;
	}
	
	virtual void ActivateLines()
	{
		let lt = LineActivatorTracer.DoTrace(self, angle, pitch, max(128, vel.length()));
		for(int i = 0; i < lt.HitLines.Size(); i++)
		{
			let ln = lt.HitLines[i];
			if(ln) ln.Activate(target, 0, SPAC_Impact);
		}
		if(BlockingLine) BlockingLine.Activate(target, 0, SPAC_Impact);
	}
	
	virtual void Handle_Homing(double turnMax = 0)
	{
		// Find nearest viable target, track target.
		if(tracer)
		{
			if(!tracer.CanCollideWith(self, false)) 
			{
				tracer = NULL;
				return;
			}
			vector3 dest = (tracer.pos.xy, tracer.pos.z+(tracer.height*0.7));
			vector3 trackingAngles = level.SphericalCoords(pos, dest, (angle, pitch));
			A_SetAngle(angle - (trackingAngles.x * homingStrength), SPF_INTERPOLATE);
			A_SetPitch(pitch - (trackingAngles.y * homingStrength), SPF_INTERPOLATE);
			if(turnMax > 0 && abs(trackingAngles.x) > turnMax ) return;
				
			// Update velocity
			vector3 newVel = HaloMath.V3Offset(angle, pitch, roll, 1.0,0,0, vel.Length());
			vel = newVel;
		}
		else
		{
			let it = BlockThingsIterator.Create(self, 1024);
			
			int mindist = int.max;
			LookExParams look;
			look.FOV = homingFOV;
			while(it.Next())
			{
				let act = it.Thing; 
				if( act == target || !act.CanCollideWith(self, false) ) continue;
				if(!act.bSHOOTABLE || act.bCORPSE || act.health <= 0) continue;
				if(target && !target.IsVisible(act, false, look)) continue;
				int dist = Distance3DSquared(act);
				if(dist < mindist) 
				{
					tracer = act;
					mindist = dist;
				}
			}
		}
	}
	
	virtual int Handle_MissileHit(Actor victim)
	{
		// Skip these victims
		if( victim == target || !victim.bSHOOTABLE || !victim.CanCollideWith(self, false) ) return 1;
				
		// Ripped through actors only take damage once.
		if(act_hits.Find(victim) != act_hits.Size()) return 1;
		
		// Determine if victim is vehicle we're the driver of
		if(target)
		{
			let curveh = Veh_Manager(target.FindInventory("Veh_Manager"));
			if(curveh && curveh.veh == victim) return 1;
		}
		hitactor = victim;
		
		// Adjust Damage
		AdjustRangeDamage();
		double scaled_damage = truedamage * GAMEPLAY_DAMAGEMOD * (1.0-rip_dmgmod);
		bool headshot = HaloMath.CheckHeadshot(self, victim);
		
		// Damage Victim
		Name dmgType = DamageType;
		let shield = ShieldProcessor(victim.FindInventory("ShieldProcessor", true));

		if(shield && shield.shields > 0)
		{
			scaled_damage = ApplyShieldDamage(scaled_damage, self, headshot);
		}
		else
		{
			if(headshot) scaled_damage *= headshot_multiplier;
			dmgType = headshot ? 'Headshot' : DamageType;
			scaled_damage = victim.GetModifiedDamage(dmgType, scaled_damage, false, self, target);
		}
		
		victim.DamageMobJ(self, target, ceil(scaled_damage * max(1,damageMult)), dmgType, 0, angle);
		if(explode_dmg > 0) A_Explode(explode_dmg, explode_radius, 0);

		// Spawn Blood
		if( victim.bISMONSTER && !victim.bNOBLOOD ) 
			victim.SpawnBlood( pos, angle, ceil(scaled_damage) );
	
		// Rip through actors
		act_hits.Push(victim);
		if(ripamount > 0) 
		{
			ripamount--;
			rip_dmgmod += rip_falloff;
			rip_dmgmod = clamp(rip_dmgmod, 0, 1.0); 
			return 1;
		}
		
		return -1;
	}
	
	virtual void DoConverge(vector3 aimpos, vector2 offs)
	{
		// Do not follow crosshair converge for vehicles
		let curveh = Veh_Manager(target.FindInventory("Veh_Manager"));
		if(curveh) return;
				
		// Converge
		if(do_converge)
		{
			vector3 toaim = level.SphericalCoords(pos, aimpos, (angle-offs.x, pitch-offs.y));
			angle -= toaim.x;
			pitch -= toaim.y;
		}
		else
		{
			angle -= offs.x;
			pitch -= offs.y;
		}
	}
	
	virtual double getTravelDistance(bool tometers = true)
	{
		double convert = tometers ? UNIT_METER : 1.0;
		return clamp(HaloMath.Distance3D(pos, spawnpos),1,int.max) / convert;
	}	
	
	virtual void AdjustRangeDamage()
	{
		// Do not calculate damage if we have no ranged damage.
		if(range_max <= 0) return;
		// Interpolate to minimum damage based on range maximum.
		double dist = getTravelDistance();
		// Negate damage at max range.
		if(dist >= range_max)
		{
			// Destroy bullet so feedback is better,
			// we wont get hit markers at above max range.
			Destroy(); 
			return;
		}
		
		// Dampen damage until minimum.
		if(dist >= range_falloff && range_falloff > 0)
		{
			double distmax = dist/range_max;
			double dmgmod = (-1.5 * (distmax**2)) + 1;
			dmgmod = clamp(dmgmod, falloff_minimum/100., 1.0);
			truedamage = default.truedamage*dmgmod;
		}
	}
	
	virtual void Init()
	{
		spawnpos = pos;
		A_SetSpeed((meterspeed / 35.)*UNIT_METER);
		
		// Re-calculate velocity with new speed.
		double cosp = cos(pitch);
		vel = (
			cos(angle) * cosp,
			sin(angle) * cosp,
			-sin(pitch)
		) * speed;
		
		SetDamage(0);
	}
}


class LineActivatorTracer : LineTracer
{
	Actor src;
	Array<Line> HitLines;
	
	play void ReTrace(double tangle, double tpitch, double dist, uint traceflags = 0)
	{
		let angles = Quat.FromAngles(tangle, tpitch, src.roll);
		vector3 dir = angles * (1.0,0,0);
		vector3 tracePos = level.vec3offset(src.pos, angles * (src.radius+16,0,0));
		if(src.player) tracePos.z = src.player.viewz;
		
		Trace(tracePos, src.CurSector, dir, dist, traceflags);
	}
	
	play static LineActivatorTracer DoTrace(Actor src, double tangle, double tpitch, double dist, uint traceflags = 0, class<LineActivatorTracer> traceType = "LineActivatorTracer")
	{
		let tracer = LineActivatorTracer(new(traceType));
		if(tracer) 
		{
			tracer.src = src;
			let angles = Quat.FromAngles(tangle, tpitch, src.roll);
			vector3 dir = angles * (1.0,0,0);
			vector3 tracePos = level.vec3offset(src.pos, angles * (src.radius+16,0,0));
			if(src.player) tracePos.z = src.player.viewz;
			
			tracer.Trace(tracePos, src.CurSector, dir, dist, traceflags);
		}
		return tracer;
	}

	// Thanks to PhantomBeta 
	// (https://github.com/Doom2fan/Se7evidas/blob/master/PK3%20Source/S7ZScript/Bases/S7_Projectile/Linetracer.ZS)
    transient Array<F3DFloor> ffloorsToIgnore;
	virtual ETraceStatus HandleWall() 
	{
		let hl = Results.HitLine;
		HitLines.push(hl);
		
        if (Results.Tier == TIER_Upper || Results.Tier == TIER_Lower)
            return TRACE_Stop;

        if (Results.ffloor && ffloorsToIgnore.Find (Results.ffloor) == ffloorsToIgnore.Size ())
		{
            ffloorsToIgnore.Push (Results.ffloor);
            return TRACE_Stop;
        }

        if (Results.Tier == TIER_Middle && !hl.backsector)
			return TRACE_Stop;
			
        if (Results.Tier == TIER_Middle && (hl.flags & Line.ML_Blocking) && (hl.flags & Line.ML_TwoSided))
            return TRACE_Skip;

        if ((hl.flags & Line.ML_3DMidTex) && !(hl.flags & Line.ML_3DMidTex_Impass))
            return TRACE_Stop;

        if (hl.flags & (Line.ML_Blocking | Line.ML_BlockEverything))
            return TRACE_Stop;

        return TRACE_Skip;
    }
	
	override ETraceStatus TraceCallback()
	{
		if(results.HitType == Trace_HitWall)
		{
			let stat = HandleWall();
			return stat;
		}
		if(results.HitType == Trace_HitActor)
		{
			return Trace_Skip;
		}
		return Trace_Stop;
	}
}