class LevelTransitionAnimator : Object
{
	ui double textFade, infoFade;
	ui double barHeight;
	ui bool fadeOut;
	bool finished;
	bool softFinish;

	static LevelTransitionAnimator Init()
	{
		let ltA = new("LevelTransitionAnimator");
		return ltA;
	}

	ui void Process(double dT)
	{
		// Don't run if there's a massive lag-spike.
		if(dT > 10) return;
		
		double barSize = 1080 * 0.15;
		if(!fadeOut)
		{	
			barHeight = HaloMath.Lerp(barHeight, barSize, 0.05 * dT);
			if(abs(barHeight-barSize) <= 3)
			{
				textFade += 0.05 * dT;
				if(textFade >= 4.0) infoFade += 0.008 * dT;
				if(infoFade >= 1.0) 
				{
					fadeOut = true;
					textFade = infoFade =  2.0;
				}
			}
		}
		else
		{
			textFade -= 0.04 * dT;
			infoFade -= 0.04 * dT;
			if(textFade <= 0.01)
			{
				softFinish = true;
				barHeight = HaloMath.Lerp(barHeight, 0, 0.035 * dT);
			}
		}	
		
		HLSBS.Fill("Black", 0, 0, 1920, barHeight); // Top 
		HLSBS.Fill("Black", 0, 1090 - barHeight, 1920, barSize); // Bottom
		
		Font textFont = "HaloFont";
		vector2 textPos = (-550,-140);
		double textScale = 0.25;
		uint textFlags = HLSBS.SS_SCREEN_BOTTOM_RIGHT | HLSBS.SS_NOASPECTCORRECTION;
		
		string mapNumber = level.MapName .. ", ";
		string levelName = level.LevelName; 
		double mapNumberWidth = (textFont.StringWidth(mapNumber) * textScale) * 2.0;
		
		HLSBS.DrawString(textFont, mapNumber, textPos, textFlags, alpha:textFade, scale:(textScale,textScale));
		
		textPos.x += mapNumberWidth + 20;
		HLSBS.DrawString(textFont, levelName, textPos, textFlags, alpha:infoFade, scale:(textScale,textScale));
		
		// This I feel like, shouldn't work?
		// But it does, sasuga GZDoom scope system.
		if(fadeOut && barHeight <= 10) finished = true;
	}
}

class Halo_OverlayUI : EventHandler
{	
	Array<Key> foundkeys;
	
	ui double prevMS, deltatime;
	Array<HitMarkers> ui_hitmarkers;
	LevelTransitionAnimator levelTransition;
	ui transient CVar cvDrawKeys;

	void AddNewKey(Key k)
	{
		string colors = (
			"Brick.Tan.Gray.Grey.Green.Brown.Gold.Red.Blue.Orange.White.Yellow."
			"Black.LightBlue.Cream.Olive.DarkGreen.DarkRed.DarkBrown.Purple."
			"DarkGray.Cyan.Ice.Fire.Sapphire.Teal" 
		);
		foundkeys.push(k);
		String keyname = k.GetClassName();
		Array<String> keytype;
		StringHelper.SplitByUppercase(keyname, keytype);
		// Find first valid key color.
		for(int i = 0; i < keytype.Size(); i++)
		{
			if(colors.IndexOf(keytype[i]) == -1) continue;
			Color kcol = Color(keytype[i]);
			k.SetShade(kcol);
		}
	}
	
	override void WorldLoaded(WorldEvent e)
	{
		foundkeys.Clear();
		let key_it = ThinkerIterator.Create("Key");
		Key foundkey;
		while( foundkey = Key(key_it.Next()) ) AddNewKey(foundkey);
		
		// Level transition(s)
		CVar doTransitions = CVar.GetCVar("halodoom_leveltransitions", players[consoleplayer]);
		if(!levelTransition && doTransitions && doTransitions.getBool()) 
			levelTransition = LevelTransitionAnimator.Init();
	}	
	override void WorldThingSpawned(WorldEvent e)
	{
		if(e.Thing is "Key") AddNewKey(Key(e.Thing));
	}
	
	override void NetworkProcess(ConsoleEvent e)
	{
		let plr = players[e.Player].mo;
		String cmd = e.Name;
		Array<String> args;
		cmd.Split(args, ":");
				
		if(args[0] == "hitmark")
		{
			uint plrnum = e.Args[0];
			// Saftey check.
			if(ui_hitmarkers.Size() < plrnum) return;
			
			bool doOverlap = args.Size() < 5 || !(args[4] ~== "replace");
			uint sndflag = doOverlap ? CHANF_OVERLAP : 0;
			if(plrnum == plr.PlayerNumber())
			{
				let dohitmarkers = CVar.GetCVar("halodoom_fx_hitmarkers", players[plrnum]);
				if(dohitmarkers && dohitmarkers.GetBool())
				{
					class<Hitmarker> type = args[1];
					uint layer = args[2].ToInt();
					if(args.Size() >= 4)
					{
						Sound snd = args[3];
						plr.A_StartSound(snd, CHAN_VOICE, sndflag);
					}
					if(type) ui_hitmarkers[plrnum].Queue(layer, type);
				}
			}
		}
	}
	
	override void WorldTick()
	{
		if(ui_hitmarkers.Size() < MAXPLAYERS)
		{
			for(int i = 0; i < MAXPLAYERS; i++)
				ui_hitmarkers.Push(new("HitMarkers"));
		}
		for(int i = 0; i < MAXPLAYERS; i++)
			ui_hitmarkers[i].Cleanup();
			
		if(levelTransition && levelTransition.finished)
		{
			levelTransition.Destroy();
			// Saftey; idk how GZDoom might handle floating pointers here.
			levelTransition = NULL; 
		}
		
	}
	
	// Keys and Hitmarkers
	override void RenderOverlay(RenderEvent e)
	{	
		// Get player
		HaloPlayer haloplr = HaloPlayer(e.Camera);
		if(!haloplr)
		{
			let halocam = HaloVehCamera(e.Camera);
			if(halocam) haloplr = HaloPlayer(halocam.source);
			if(!haloplr) return;
		}
		
		vector2 hitxmid = (0,0);
		if(haloplr && haloplr.CheckCrosshairLowered()) 
			hitxmid.y = haloplr.xhair_lowpos;
		
		// Draw HUD projections
		if(!cvDrawKeys) cvDrawKeys = CVar.GetCVar("halodoom_keyoverlays", e.Camera.player);
		if(cvDrawKeys && cvDrawKeys.getBool() && !automapactive) DrawKeys(e);
		
		// Hitmarker(s)
		uint plrnum = haloplr.PlayerNumber();

		ui_hitmarkers[plrnum].Process();
		ui_hitmarkers[plrnum].Animate(deltatime, hitxmid);
		
		if(levelTransition)
			levelTransition.Process(deltaTime);
		
		// Keep track of time, always.
		if(!prevMS)
		{
			prevMS = MSTime();
			return;
		}
		double ftime = MSTime()-prevMS;
		prevMS = MSTime();
		double dtime = 1000.0 / 60.;
		deltatime = (ftime/dtime);
	}
	
	ui void DrawKeys(RenderEvent e)
	{
		Actor rendersrc = e.Camera;
		// Very important to note here that, Keys should NEVER be removed
		// from this Array. RenderOverlay runs at your NATIVE framerate and thus
		// runs faster than the Play-scopes ability to write to foundkeys.
		// This means, you can potentially get access out of bounds depending 
		// on performance which is, really bad.
		for(int i = 0; i < foundkeys.Size(); i++)
		{
			Key k = foundkeys[i];
			if(k && !k.Owner)
			{
				// Project KeyNAV
				HLViewProjection viewproj = HLSBS.GetEventViewerProj(e);
				bool infront;
				vector2 apos;
				[infront, apos] = HLSBS.GetActorHUDPos (
					viewproj,
					k, 0, 0, k.height*1.5
				);
				if(infront) 
				{
					int keytint = k.fillcolor;
					double dist = rendersrc.Distance3D(k);
					vector2 distscale = (0.15,0.15);
					distscale *= dist/1200.;
					distscale.x = clamp(distscale.x, 0.10, 0.20);
					distscale.y = clamp(distscale.y, 0.10, 0.20);
					
					HLSBS.DrawImage("HDENAV", apos, 0, 0.6, distscale, tint:keytint, absolute:true);
					HLSBS.DrawString3D(
						"BigFont", 
						String.Format("%dm",dist/UNIT_METER), 
						apos, 0, 
						Font.CR_GOLD, 
						scale:(1.25,1.25),
						distance: 300.
					);
				}
			}
		}
	}
}