class HaloStatusBar : BaseStatusBar
{
	const ANIM_FPS = 60;
	
	HaloPlayer haloplr;
	HUDFont mHUDFont;
	
	// Delta-time logic.
	double prevMS; 
	double deltatime;
	
	// Crosshair vars
	double curbloom;
	
	// Interpolated vars
	double curshields;
	double dimalpha;
	
	// Timers
	double lowshield_timer;
	bool shieldwarn;
	
	// Font(s)
	Font fnt;
	
	// Basic Functions
	mixin BasicHUDFeatures;

	override void Init()
	{
		Super.Init();
		SetSize(0, 320, 200);
		if(CPlayer) haloplr = HaloPlayer(CPlayer.mo);
		
		// Create the font used for the fullscreen HUD
		fnt = "BigFont";
		mHUDFont = HUDFont.Create(fnt);
	}
		
	override void Draw (int state, double TicFrac)
	{
		if(!automapactive) Super.Draw(state, TicFrac);
				
		// Always draw HUD
		BeginHUD();
		DrawMainBar (TicFrac);
	}
	
	void DrawMainBar (double TicFrac)
	{
		if(CPlayer && CPlayer.mo)
		{	
			if(!haloplr) 
			{
				haloplr = HaloPlayer(CPlayer.mo);
				return;	
			}
			
			// Vitals
			DrawBars(); 
			
			// Weapons
			if(!automapactive)
			{
				DrawRadar();
				DrawCompass();
				DrawCrosshairs();
			}
			
			// Keys and Objectives
			DrawKeys(CPlayer, 50, 10, 30,30);			
			DrawObjectives();
			
			// Keep track of time, always.
			if(!prevMS)
			{
				prevMS = MSTime();
				return;
			}
			double ftime = MSTime()-prevMS;
			prevMS = MSTime();
			double dtime = 1000.0 / ANIM_FPS;
			deltatime = (ftime/dtime);
		}
	}

	void DrawCrosshairs()
	{
		HaloGun weap = HaloGun(haloplr.player.ReadyWeapon);
		if(!weap) return;
		
		string crosshair = weap.wcrosshair;
		double bloom = weap.spreadmod;
		vector2 retsize = (0.65,0.65);
		vector2 midpos = (0,0);
		retsize *= 1.0+curbloom;
		HLSBS.DrawImage(crosshair, midpos, HLSBS.SS_SCREEN_CENTER, 0.65, scale:retsize);
		double ispd = 0.12;
		if(bloom > curbloom) ispd = 0.5; 
		curbloom = HaloMath.Lerp(curbloom, bloom, ispd*deltatime);
	}

	const BLINKRATE = ANIM_FPS/6.;
	void DrawBars()
	{
		if(haloplr.shields <= 0)
		{
			lowshield_timer -= 1*deltatime;	
			if(lowshield_timer < 0) 
			{
				lowshield_timer = BLINKRATE; 
				shieldwarn = !shieldwarn;
			}
		}
		else
		{
			lowshield_timer = BLINKRATE;
			shieldwarn = false;
		}
		
		if( haloplr.regen_timer >= HaloPlayer.REGENTIME && dimalpha > 0 &&
			haloplr.shields < haloplr.maxshields )
		{
			dimalpha = HaloMath.Lerp(dimalpha, 0, 0.025*deltatime);
			Screen.Dim("42ADF5",dimalpha,0,0,Screen.GetWidth(),Screen.getHeight());
		}
		else
			dimalpha = 0.4;

		string shbg = shieldwarn ? "sh_rbg"  : "sh_nbg";
		string shou = shieldwarn ? "sh_rout" : "sh_nout";
		
		vector2 shieldpos = (957,50); //(1550, 50);
		vector2 healthpos = (577, 77); //(1740, 77);
		if(curshields != haloplr.shields) curshields = HaloMath.Lerp(curshields, haloplr.shields, 0.2*deltatime);
		uint leftflags = BaseStatusBar.SHADER_REVERSE;
		HLSBS.DrawBar("sh_barL",shbg.."L",curshields,haloplr.maxshields,shieldpos-(253,0), 0,leftflags, 0.8,1.0, (1.0,1.35));
		HLSBS.DrawBar("sh_barR",shbg.."R",curshields,haloplr.maxshields,shieldpos, 0,0, 0.8,1.0, (1.0,1.35));
		
		shieldpos += (126, 42);
		HLSBS.DrawImage(shou.."R",shieldpos,scale:(1.0,1.3));
		HLSBS.DrawImage(shou.."L",shieldpos-(251,0),scale:(1.0,1.3));
		
		int healthbars = clamp(ceil((haloplr.health / 5.)), 1, 9);
		HLSBS.DrawImage("ui_hbar"..healthbars, healthpos, 0, 0.8, scale:(-1.0,1.15));
		healthpos += (508,0);
		HLSBS.DrawImage("ui_hbar"..healthbars, healthpos, 0, 0.8, scale:(1.0,1.15));
	}

	// Planned to implement, currently unimplemented.
	void DrawObjectives() {}
	void DrawRadar() {}
	void DrawCompass() {}

	void DrawFullScreenStuff (double TicFrac) {}
}

// Standard HUD Functions.
mixin class BasicHUDFeatures 
{
	void DrawImageToBox(TextureID tex, int x, int y, int w, int h, double trans = 0.75, bool animate = false)
	{
		double scale1, scale2;

		if (tex)
		{
			let texsize = TexMan.GetScaledSize(tex);

			scale1 = w / texsize.X;
			scale2 = h / texsize.Y;
			scale1 = min(scale1, scale2);
			if (scale2 < scale1) scale1=scale2;

			x += w >> 1;
			y += h;

			w = (int)(texsize.X * scale1);
			h = (int)(texsize.Y * scale1);

			screen.DrawTexture(tex, animate, x, y,
				DTA_KeepRatio, true,
				DTA_VirtualWidth, 1920, DTA_VirtualHeight, 1080, DTA_Alpha, trans, 
				DTA_DestWidth, w, DTA_DestHeight, h, DTA_CenterBottomOffset, 1);
		}
	}
	// Key Stuff
	virtual bool DrawOneKey(int xo, int x, int y, int w, int h, Key inv, in out int c)
	{
		TextureID icon, nosprite;
		nosprite = TexMan.CheckForTexture("TNT1A0", TexMan.Type_Sprite);
		
		if (!inv) return false;
		
		TextureID AltIcon = inv.AltHUDIcon;
		if (!AltIcon.Exists()) return false;	// Setting a non-existent AltIcon hides this key.

		if (AltIcon.isValid()) 
		{
			icon = AltIcon;
		}
		else if (inv.SpawnState && inv.SpawnState.sprite!=0)
		{
			let state = inv.SpawnState;
			if (state != null) icon = state.GetSpriteTexture(0);
			else icon.SetNull();
		}
		// missing sprites map to TNT1A0. So if that gets encountered, use the default icon instead.
		if (icon.isNull() || icon == nosprite) icon = inv.Icon; 

		if (icon.isValid())
		{
			DrawImageToBox(icon, x, y, w, h);
			return true;
		}
		return false;
	}
	virtual int DrawKeys(PlayerInfo CPlayer, int x, int y, int w, int h)
	{
		int yo = y;
		int xo = x;
		int i;
		int c = 0;
		Key inv;

		if (!deathmatch)
		{
			int count = Key.GetKeyTypeCount();
			
			// Go through the key in reverse order of definition, because we start at the right.
			for(int i = count-1; i >= 0; i--)
			{
				if ((inv = Key(CPlayer.mo.FindInventory(Key.GetKeyType(i)))))
				{
					if (DrawOneKey(xo, x - (w+1), y, w, h, inv, c))
					{
						x += (w+1);
						if (++c >= 6)
						{
							x = xo;
							y += (h+1);
							c = 0;
						}
					}
				}
			}
		}
		if (x == xo && y != yo) y += 11;	// undo the last wrap if the current line is empty.
		return y - 11;
	}
}
