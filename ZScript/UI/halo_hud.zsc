class HaloHUD_Message : HaloMessage
{
	// Used for custom HUD message behavior	
	override void Animate(double dt, double spd)
	{
		switch(stage)
		{
			// Scale up then back down.
			case 0:
				if(abs(scale.Length() - desired_scale.Length()) <= 0.01)
				{
					desired_scale *= 0.75;
					stage++;
				}
				alpha = HaloMath.Lerp(alpha, desired_alpha, spd);
			break;
			
			// Begin fadeout.
			case 1:
				alpha = 3.0;
				stage = 2;
			break;
			
			// Process fadeout completion.
			case 2:
				alpha -= 0.01 * dt;
				if(alpha <= 0) msg = "";
			break;
		}	
	}
}

class BarebonesHUD : HaloHUD
{
	// Just here for testing stuff.
} 

class HaloDoomHUD : HaloHUD
{
	// Interpolated vars
	double curshields;
	double curbattery;
	double dashmeter;
	double lowAmmoBlink;
	
	// Timers
	double lowshield_timer;
	bool shieldwarn;

	override void Init(HaloStatusBar base)
	{
		super.Init(base);
		
		// Messages setup
		msgpos = (80, 400);
	}
		
	override HaloMessage CreateMessage(String msg)
	{
		Color msgcol = 0x4002a7de;
		vector2 msgscale = (1.0, 0.8);
		
		let hmsg = HaloMessage.CreateMessage("Fonts/HaloSmallerFont.fon2", msg, msgpos, msgscale, tint:msgcol, msgClass:"HaloHUD_Message");
		return hmsg;
	}
	
	override void Draw (int state, double deltaTime)	
	{
		super.Draw(state, deltaTime);

		DrawElements();
	}
	
	virtual void DrawElements()
	{
		// Vitals
		DrawBars(); 
		
		// Weapons
		if(!automapactive)
		{
			DrawCompass();
			DrawAbilities();
			DrawWeaponsAmmo();
			DrawRadar();
		}
		
		// Keys and Objectives
		DrawKeys(base.CPlayer, 50, 10, 30,30);			
		DrawObjectives();
	}

	// 24 ammo per line.
	const AMMO_MAX = 14.;
	const AMMOG_SIZE = 10. * 1.25;
	virtual void DrawWeaponsAmmo()
	{
		Weapon curweap = haloplr.player.ReadyWeapon;
		if(!curweap) return; // Just in case somehow the player has no weapon
		
		// Find other weapon manually.
		let haloweap = HaloGun(curweap);
		Weapon otherweap = haloweap ? haloweap.FindNextWeapon() : curweap;

		Halogun halo_curweap, halo_otherweap;
		halo_curweap = HaloGun(curweap);
		halo_otherweap = HaloGun(otherweap);
		
		String weap1_icon = "";
		String weap2_icon = "";
		vector2 weap1_scale, weap2_scale;
		vector2 weap1_offs, weap2_offs;
		[weap1_icon, weap1_scale] = base.GetWeaponUIDetails(curweap,  (1.5,1.5), (128,45));
		[weap2_icon, weap2_scale] = base.GetWeaponUIDetails(otherweap, (1.0,1.0), (80,80), forceResScale:true);
		
		if(!halo_curweap) weap1_offs = (50,100);
		if(!halo_otherweap && otherweap) weap2_offs = (80,30);
		
		// Weapon housing
		HLSBS.DrawImage("Graphics/UI/WepHousing.png", (1700,120), HLSBS.SS_NOASPECTCORRECTION, 0.8, (1.7,1.9)); 
			
		// Weapon Icons
		uint iconFlags = HLSBS.SS_NOASPECTCORRECTION;
		HLSBS.DrawImage(weap1_icon, (1745,75)+weap1_offs, iconFlags, 0.8, weap1_scale);
		if(otherweap) HLSBS.DrawImage(weap2_icon, (1820,153)+weap2_offs, iconFlags, 0.8, weap2_scale);
		
		if(halodoom_unlimitedbackpack)
		{
			Weapon weap = NULL;
			Array<int> slots;
			slots.Resize(10);
			
			for(let i = haloplr.Inv; i; i = i.Inv)
			{
				weap = Weapon(i);
				if(!weap) continue;
				
				double num = weap.slotnumber;
				if(num < 0) num = 0;
				
				double cnt = slots[num];
				vector2 offs = (
					0, (num*100) + cnt*20
				);
				if(!HaloGun(weap)) 
				{
					offs.x += 25;
					offs.y += 20;
				}
				
				vector2 scale;
				string icon;
				[icon, scale] = base.GetWeaponUIDetails(weap, (1.0,1.0));
				HLSBS.DrawImage(icon, (1850,200)+offs, iconFlags, 0.8, scale*0.5);
				slots[num]++;
			}	
			for(int i = 1; i <= slots.Size(); i++)
			{
				HLSBS.DrawString(fntHaloAmmo, i.."", (1800, 280+((i-1)*100)), flags:iconFlags, scale:(0.05,0.05));
			}
		}
		
		vector2 ampos = (1640, 160);
		bool skipAmmoDraw = halo_curweap.DrawAmmoUI(ampos, deltaTime);
		
		// Ammo display
		if(!skipAmmoDraw)
		{
			if(halo_curweap && halo_curweap.uses_battery)
			{
				double cur_charge = haloplr.countinv(curweap.AmmoType2);
				curbattery = HaloMath.Lerp(curbattery, cur_charge, 0.15 * deltatime);
				
				let ammoDefs = GetDefaultByType(curweap.AmmoType2);
				double max_charge = ammoDefs.MaxAmount;
				if(haloplr.countinv("Backpack")) 
					max_charge = max(max_charge, ammoDefs.BackpackMaxAmount);
				
				double charge_perc = curbattery/max_charge;

				if(charge_perc > 0)
				{
					Color tint = 0;
					if(charge_perc < 0.4) tint = Color(128, 255,8,8);
					HLSBS.DrawImage("WI_BTRY", ampos+(-170,-30), iconFlags, 0.35, (-1.75,1.5), tint:Color(180,0,0,0));
				
					double xClip = max(0, 1.0-charge_perc) * 195;
					HLSBS.SetClipRect(1571 + xClip, 120, 195 - xClip, 20, flags:iconFlags);
					HLSBS.DrawImage("WI_BTRY", ampos+(-170,-30), iconFlags, 0.8, (-1.75,1.5), tint:tint);
					HLSBS.ClearClipRect();
				}
				
				// Heat gauge
				if(halo_curweap.heat > 0.05)
				{
					int curHeat = min(9, (halo_curweap.heat*1.10) * 9);
					string heatbars = String.Format("Graphics/UI/Heatbar/HB%d.png", curHeat);
					HLSBS.DrawImage(heatbars, ampos + (-60,-10), flags:iconFlags, scale:(-1.5,1.5));
				}
			}
			else if(curweap.AmmoType2 && curweap.AmmoType2 != curweap.AmmoType1 && halo_curweap)
			{
				// Draw projectile ammunition 
				
				// curweap.hudAmmo_graphic, hudAmmo_spacing, hudAmmo_XMax, hudAmmo_YMax
				
				double cur_ammo  = haloplr.countinv(curweap.AmmoType2);
				double clip_ammo = GetDefaultByType(curweap.AmmoType2).MaxAmount;
				vector2 amoffs;
		
				Color tint = 0;
				if( (cur_ammo / clip_ammo) <= 0.4 ) 
				{
					double tintAlpha = sin(lowAmmoBlink * 5) * 160;
					tint = Color(int(tintAlpha), 255,8,8);
					lowAmmoBlink += deltaTime;
				}
				else
					lowAmmoBlink = 0;
				
				if(halo_curweap.hudAmmo_YMax > 0)
				{
					int ymax = ceil(clip_ammo/halo_curweap.hudAmmo_YMax);
					for(int i = 0; i < clip_ammo; i++)
					{
						double iconAlpha = (cur_ammo--) > 0 ? 0.8 : 0.15;
						vector2 ammoOffs = (115 + halo_curweap.hudAmmo_xOffs, -25 + halo_curweap.hudAmmo_yOffs);
						vector2 amdrawOffs = (amoffs.x * halo_curweap.hudAmmo_xSpacing, amoffs.y * halo_curweap.hudAmmo_ySpacing) * 1.25;
										
						HLSBS.DrawImage(
							halo_curweap.hudAmmo_graphic, 
							ampos + amdrawOffs + ammoOffs, 
							flags:iconFlags, iconAlpha, (1.25,1.25) * halo_curweap.hudAmmo_scale, tint:tint
						);
						
						amoffs.y++;
						if(amoffs.y >= ymax) 
						{
							amoffs.y = 0;
							amoffs.x--;
						}
					}
				}
				
				if(halo_curweap.hudAmmo_XMax > 0)
				{
					int xmax = halo_curweap.hudAmmo_XMax;
					for(int i = 0; i < clip_ammo; i++)
					{
						double iconAlpha = (cur_ammo--) > 0 ? 0.8 : 0.15;
						vector2 ammoOffs = (-75 + halo_curweap.hudAmmo_xOffs, -25 + halo_curweap.hudAmmo_yOffs);
						vector2 amdrawOffs = (amoffs.x * halo_curweap.hudAmmo_xSpacing, amoffs.y * halo_curweap.hudAmmo_ySpacing) * 1.25;
										
						HLSBS.DrawImage(
							halo_curweap.hudAmmo_graphic, 
							ampos + amdrawOffs + ammoOffs, 
							flags:iconFlags, iconAlpha, (1.25,1.25) * halo_curweap.hudAmmo_scale, tint:tint
						);
											
						amoffs.x++;
						if(amoffs.x >= xmax) 
						{
							amoffs.x = 0;
							amoffs.y++;
						}
					}
				}
			}
			// Ammo Count
			HLSBS.DrawString(
				fntHaloAmmo, haloplr.countinv(curweap.AmmoType1).."", 
				(1584, 56), flags:HLSBS.SS_TEXT_CENTER | iconFlags, scale:(0.15,0.15)
			);
		}
		
		// Draw grenades
		vector2 nadepos   = (215, 80);
		vector2 nadescale = (1.0, 1.0);
		
		let curNade = haloplr.activeGrenade;
		for(int i = 0; i < base.grenadeTypes.Size(); i++)
		{
			let nade = FragGrenades(GetDefaultByType(base.grenadeTypes[i]));
			String graphic = String.Format("Graphics/UI/%s", nade.hudIcon);
			String borderGraphic = "border_inactive.png";
			int nadeAmt = haloplr.countinv(nade.GetClass());
			Color tint = 0; Color borderTint = 0;
			if(!nadeAmt) 
			{
				tint = Color(128, 255,8,8);
				borderTint = Color(64, 255,0,0);
			}
			
			// Check if grenade is valid and selected.
			if( curNade && curNade.getClass() == nade.GetClass() && curNade.amount > 0	)
				borderGraphic = "border_active.png";
			
			// Border
			HLSBS.DrawImage("Graphics/UI/Grenades/" .. borderGraphic, nadePos + (24,0), scale:(2.0,1.0), tint:borderTint);

			// Icon
			HLSBS.DrawImage(graphic, nadepos, scale:nadescale, tint:tint);
			HLSBS.DrawString(fntHaloAmmo, String.Format("%d", nadeAmt), nadepos+(32,0), scale:(0.18,0.15) * 0.75, tint:tint);
			
			nadepos.x += 160;
		}
	}
	
	virtual void DrawAbilities(vector2 offs = (0,0), double scale = 1.0)
	{	
		powerupPos = (160,740) + ((-16,-88)*scale) + offs;
		powerupScale = scale;
		
		vector2 ablpos = (160,740) + offs;
		double ablscale = 0.85 * scale;
		if(haloplr.enable_dash)
		{
			double dashperc = (haloplr.dashcounter / double(haloplr.dashmax));
			double fullpos = 52 * (1.0 - dashperc);
			dashmeter = HaloMath.Lerp(dashmeter, fullpos, 0.10 * deltatime);
			
			HLSBS.DrawImage("DASHBG", ablpos, scale:(ablscale,ablscale));
			HLSBS.SetClipRect(ablpos.x - (24*scale), ablpos.y - (32*scale), dashmeter*scale, 64*scale);
			HLSBS.DrawImage("DASHCRGE", ablpos, scale:(ablscale,ablscale));
			HLSBS.ClearClipRect();
			if(dashperc <= 0)
				HLSBS.DrawImage("DASHFULL", ablpos, scale:(ablscale,ablscale));
			ablpos.x += 128;
		}
		
		if(haloplr.enable_grapple)
		{
			if(!haloplr.grapple && haloplr.gpl_validsurface)
			{
				HLSBS.DrawImage("GRPLFULL", ablpos, scale:(ablscale,ablscale));
				HLSBS.DrawImage("DASHFULL", ablpos, scale:(ablscale,ablscale));
			}
			else
			{
				HLSBS.DrawImage("GRPLEMTY", ablpos, scale:(ablscale,ablscale));
			}
			ablpos.x += 128;
		}
	}

	virtual void DrawBars()
	{
		double BLINKRATE = base.ANIM_FPS/6.;
		if(haloplr.shields <= 0)
		{
			lowshield_timer -= 1*deltatime;	
			if(lowshield_timer < 0) 
			{
				lowshield_timer = BLINKRATE; 
				shieldwarn = !shieldwarn;
			}
		}
		else
		{
			lowshield_timer = BLINKRATE;
			shieldwarn = false;
		}
		base.DrawShieldRegen();
		
		// Constants
		string shbg  = shieldwarn ? "sh_rbg"  : "sh_nbg";
		string shou  = shieldwarn ? "sh_rout" : "sh_nout";
		string shgfx = "sh_bar";
		uint flags = HLSBS.SS_NOASPECTCORRECTION;
		vector2 shieldpos  = (958, 88); //(1550, 50);
		vector2 healthpos  = (577, 77); //(1740, 77);
		vector2 shieldmin  = (958,  0); //(958,   0);  
		vector2 shieldclip = (706,504); //(706, 504);
		
		// Interpolate Shields
		if(curshields != haloplr.shields) 
		{
			double ispd = (haloplr.shields > curshields) ? 0.05 : 0.2;
			curshields = HaloMath.Lerp(curshields, haloplr.shields, ispd*deltatime);
		}
		if(curshields == 0) curshields = haloplr.shields;
		double shieldperc = curshields / haloplr.maxshields;
		
		// Setup shield parameters
		if(shieldperc > 2.0) 
		{
			shbg = "sh_bar1";
			shgfx = "sh_bar2";
			shieldperc -= 2.0;
		}
		else if(shieldperc > 1.0) 
		{
			shbg = "sh_bar";
			shgfx = "sh_bar1";
			shieldperc -= 1.0;
		}
		
		// Shield outline and background
		HLSBS.DrawImage(shou, shieldpos, flags, 0.8, scale:(1.0,1.35));
		HLSBS.DrawImage(shbg, shieldpos, flags, 0.8, scale:(1.0,1.35));
		
		// Shield clip
		shieldclip.x = HaloMath.Lerp(shieldclip.x, shieldmin.x, 1.-shieldperc);
		shieldclip.y = HaloMath.Lerp(shieldclip.y, shieldmin.y, 1.-shieldperc);
		
		// Shield graphics
		HLSBS.SetClipRect(shieldclip.x,32,shieldclip.y,86);
		HLSBS.DrawImage(shgfx, shieldpos, flags, 0.8, scale:(1.0,1.35));
		HLSBS.ClearClipRect();	

		// Health
		double maxHP = haloplr.GetMaxHealth();
		double hpratio = haloplr.health / maxHP; 
		int healthbars = clamp(ceil(hpratio * 9), 1, 25);
		string hbar = String.Format("Graphics/UI/Healthbar/ui_hbar%d.png", healthbars);
		
		HLSBS.DrawImage(hbar, healthpos, flags, 0.8, scale:(-1.0,1.15));
		healthpos += (508,0);
		HLSBS.DrawImage(hbar, healthpos, flags, 0.8, scale:(1.0,1.15));
	}

	virtual void drawRadarLine( double x0, double y0, double x1, double y1, Color col, vector2 origin = (0,0), double maxdist = 128)
	{	
		double scrw = Screen.getWidth();
		double scrh = Screen.getHeight();
		double xres = scrw/1920.;
		double yres = scrh/1080.;

		double fromdist = HaloMath.Distance2D((x0,y0), origin);
		double todist = HaloMath.Distance2D((x1,y1), origin);
		if(fromdist > maxdist*1.2 && todist > maxdist*1.2) return;
		
		if( (fromdist > maxdist || todist > maxdist) ) 
		{
			double lineangle = atan2(y1-y0, x1-x0);
			double dist = HaloMath.Distance2D((x0,y0),(x1,y1));
			vector2 linedir = (cos(lineangle), sin(lineangle));
			double step = 1;
			
			double maxdist_fast = maxdist*maxdist;
			for(int i = 0; i < dist; i+=step)
			{
				vector2 pixpos = (x0 + (linedir.x*i), y0 + (linedir.y*i) );
				double fulldist = HaloMath.Distance2D(pixpos, origin);
				if(fulldist > maxdist) continue;
				HLSBS.DrawImage("HPXL", pixpos, 0, 1.0, (0.5,0.5), tint:col);
			}
			return;
		}

		Screen.DrawThickLine(x0*xres,y0*yres,x1*xres,y1*yres,2,col,base.alpha*255);
	}	
	
	
	vector2 SwapVector(vector2 vec)
	{
		double oldx = vec.x;
		vec.x = vec.y;
		vec.y = oldx;
		return vec;
	}
	virtual void DrawRadar(vector2 offs = (0,0), double scale = 1.0)
	{
		// -- CVars / Constants --
		double zoom = 7;
		double radarsize = 120 * scale;
		double minimap_renderdist = 800;
		double acor = HLSBS.GetAspectScale();
		Vector2 baseoffs = ( 230, 894 ) + offs;
		Vector2 plrpos2D = (haloplr.pos.x, haloplr.pos.y);
		Color linecol = Color( 0xFF, 0x79, 0xC1, 0xC9);
		Color radrcol = Color( 0xFF, 0x2D, 0x3E, 0x5B);
		Vector2 dp = Actor.RotateVector( (0,0), haloplr.angle-90 );
		Vector2 map_middle = (dp.x+baseoffs.x,dp.y+baseoffs.y);
			
		// Draw radar bg
		HLSBS.DrawImage("RADARBG", baseoffs, scale:(scale,scale));
		
		// Draw Minimap
		if( base.showMinimap && base.showMinimap.getBool() )
		{
			for (int i = 0; i < Level.Lines.Size(); i++)
			{
				Line ln = Level.Lines[i];
				if( !(ln.flags & Line.ML_MAPPED) ) continue;
				
				Vector2 ln_pos = ln.v1.p;
				Vector2 ln_len = ln.v2.p;
				
				// Check render distance
				if( abs(ln_pos.x-plrpos2D.x) > minimap_renderdist && abs(ln_len.x-plrpos2D.x) > minimap_renderdist || 
					abs(ln_pos.y-plrpos2D.y) > minimap_renderdist && abs(ln_len.y-plrpos2D.y) > minimap_renderdist    )
					continue;
				
				ln_pos = Actor.RotateVector(SwapVector(ln_pos-plrpos2D),haloplr.angle+180);
				ln_len = Actor.RotateVector(SwapVector(ln_len-plrpos2D),haloplr.angle+180);					
				ln_pos += baseoffs*zoom;
				ln_len += baseoffs*zoom;
				ln_pos /= zoom;
				ln_len /= zoom;
				ln_pos.x *= acor;
				ln_len.x *= acor;
				ln_pos.x += map_middle.x * (1 - acor);
				ln_len.x += map_middle.x * (1 - acor);
				
				vector2 mid = map_middle;
				mid.x *= acor;
				mid.x += map_middle.x * (1 - acor);
				drawRadarLine(ln_pos.x,ln_pos.y,ln_len.x,ln_len.y,linecol, mid, radarsize*0.94);
			}
		}
		
		// Draw doomguy and Radar	
		double maxdist = 500;
		let act_it = BlockThingsIterator.Create(haloplr, maxdist*2.0);
		while(act_it.Next())
		{	
			let obj = act_it.Thing;	
			if(maxdist <= 0) break;
			if(!obj.bSHOOTABLE) continue;
			
			double x = haloplr.pos.x - obj.pos.x;
			double y = haloplr.pos.y - obj.pos.y;
			
			double frontangle = haloplr.angle+180;
			vector2 delta = Actor.RotateVector(SwapVector((x,y)), frontangle);
			delta.x /= zoom;
			delta.y /= zoom;
			
			if( !(obj is haloplr.GetClass()) && obj.target )
			{
				if(obj.health <= 0 || obj.bCORPSE || !obj.bISMONSTER) continue;
				String basegraphic = "ALLYDOT"; 
				if(obj.target != NULL && !obj.bFRIENDLY && obj.bSOLID && obj.bSHOOTABLE)
					basegraphic = "ENEMYDOT";
				else if(obj.bFRIENDLY && obj.bSHOOTABLE)
					basegraphic = "ALLYDOT";
				
				vector2 finalpos = ((map_middle.x-delta.x), (map_middle.y-delta.y));
				double drawdist; 
				[finalpos, drawdist] = HaloMath.ClampVector(finalpos, map_middle, radarsize*0.98);
				finalpos.x *= acor;
				finalpos.x += map_middle.x * (1 - acor);
				
				vector2 dScale = (1.0, 1.0);
				dScale *= clamp(1.0-(drawdist/512.), 0.5, 1.0);
				
				HLSBS.DrawImage(basegraphic, finalpos, 0, (drawdist>radarsize ? 0.6 : 1.0), dScale);
			}
		}
		
		// Draw Radar middle, "player"
		HLSBS.DrawImage("RADARMID", baseoffs);	
	}

	// Planned to implement, currently unimplemented.
	void DrawObjectives() {}
	void DrawCompass() {}
}

// Halo CE
class HaloCE_Message : HaloMessage
{
	// Used for custom HUD message behavior	
	override void Animate(double dt, double spd)
	{
		switch(stage)
		{
			case 0:
				alpha = desired_alpha * 3.0;
				stage++;
			break;
			
			// Begin fadeout.
			case 1:
				alpha -= 0.01 * dt;
				if(alpha <= 0) msg = "";
			break;
		}	
	}
}

class HaloCE_HUD : HaloDoomHUD
{	
	override void Init(HaloStatusBar base)
	{
		super.Init(base);
		
		// Messages setup
		msgpos = (40, 200);
	}
		
	override HaloMessage CreateMessage(String msg)
	{
		Color msgcol = 0x4002a7de;
		vector2 msgscale = (1.0, 0.8) * 0.75;
		
		let hmsg = HaloMessage.CreateMessage("Fonts/HaloSmallerFont.fon2", msg, msgpos, msgscale, tint:msgcol, msgClass:"HaloCE_Message");
		return hmsg;
	}
	
	override void DrawElements()
	{
		// Vitals
		DrawBars(); 
		
		// Weapons
		if(!automapactive)
		{
			DrawCompass();
			DrawAbilities((-25,75),0.7);
			DrawWeaponsAmmo();
			DrawRadar((-50,50), 0.8);
		}
		
		// Keys and Objectives
		DrawKeys(base.CPlayer, 50, 10, 30,30);			
		DrawObjectives();
	}
	
	// 24 ammo per line.
	override void DrawWeaponsAmmo()
	{
		if(!haloplr) return;
		Weapon curweap = haloplr.player.ReadyWeapon;
		if(!curweap) return; // Just in case somehow the player has no weapon
		
		// Find other weapon manually.
		let haloweap = HaloGun(curweap);
		Weapon otherweap = haloweap ? haloweap.FindNextWeapon() : curweap;
		
		uint weapDrawFlags = HLSBS.SS_NOASPECTCORRECTION;
		string weapHousing  = "Graphics/UI/CE_HUD/Combat/CEWepHousing.png";
		string grenHousing  = "Graphics/UI/CE_HUD/Combat/CEGrenadeHousing.png";
		string weapBullet   = "Graphics/UI/CE_HUD/Combat/CEWeapIcon_Bullet.png";
		string weapBattery  = "Graphics/UI/CE_HUD/Combat/CEWeapIcon_Battery.png";
		string weapChargeBG = "Graphics/UI/CE_HUD/Combat/CEWeapHeatMeter.png";
		string weapChargeFG = "Graphics/UI/CE_HUD/Combat/CEWeapHeatMeter_FG.png";
		string weapBatteryFill = "Graphics/UI/CE_HUD/Combat/CEWeapIcon_BatteryFill.png";
		vector2 weapPos = (160,70);
		double weapScale = 1.5;
		
		if(halodoom_unlimitedbackpack)
		{
			Weapon weap = NULL;
			Array<int> slots;
			slots.Resize(10);
			
			for(let i = haloplr.Inv; i; i = i.Inv)
			{
				weap = Weapon(i);
				if(!weap) continue;
				
				double num = weap.slotnumber;
				if(num < 0) num = 0;
				
				double cnt = slots[num];
				vector2 offs = (
					0, (num*100) + cnt*20
				);
				if(!HaloGun(weap)) 
				{
					offs.x += 25;
					offs.y += 20;
				}
				
				vector2 scale;
				string icon;
				[icon, scale] = base.GetWeaponUIDetails(weap, (1.0,1.0));
				HLSBS.DrawImage(icon, (1850,200)+offs, weapDrawFlags, 0.8, scale*0.5);
				slots[num]++;
			}	
			for(int i = 1; i <= slots.Size(); i++)
			{
				HLSBS.DrawString(fntHaloAmmo, i.."", (1800, 280+((i-1)*100)), flags:weapDrawFlags, scale:(0.05,0.05));
			}
		}
		
		HLSBS.DrawImage(weapHousing, weapPos, flags:weapDrawFlags, scale:(weapScale,weapScale)); 
		if(haloweap && haloweap.uses_battery)
		{
			HLSBS.DrawImage(weapBattery, weapPos + (55,0), flags:weapDrawFlags, scale:(weapScale,weapScale)); 
			if(haloweap.ammotype2 != haloweap.ammotype1)
			{
				let ammodefs = GetDefaultByType(haloweap.ammotype2);
				double perc = haloplr.countinv(haloweap.ammotype2) / double(ammodefs.maxamount);
				HLSBS.SetClipRect(weapPos.x + 24, weapPos.y - 16, 60 * perc, 32); 
			}
			HLSBS.DrawImage(weapBatteryFill, weapPos + (55,0), flags:weapDrawFlags, scale:(weapScale,weapScale)); 
			HLSBS.ClearClipRect();
		}
		else
		{
			HLSBS.DrawImage(weapBullet, weapPos + (55,0), flags:weapDrawFlags, scale:(weapScale,weapScale)); 
		}
		
		// Draw reserve ammunition
		int reserve_ammo = curweap.AmmoType1 ? haloplr.CountInv(curweap.AmmoType1) : haloplr.CountInv(curweap.AmmoType2);
		int cur_ammo = curweap.AmmoType2 ? haloplr.CountInv(curweap.AmmoType2) : haloplr.CountInv(curweap.AmmoType1);
		
		HLSBS.DrawString(
			fntHaloAmmo,
			String.Format("%03d", reserve_ammo), weapPos+(12,-12),
			flags:HLSBS.SS_TEXT_RIGHT | weapDrawFlags,
			scale:(0.18,0.15) * 0.85
		);
		
		// Draw active ammunition
		vector2 ampos = weapPos + (-15,60);
		bool skipAmmoDraw = haloweap && haloweap.DrawAmmoUI(ampos, deltaTime);
		
		if(!skipAmmoDraw && haloweap && curweap.AmmoType2)
		{
			double clip_ammo = GetDefaultByType(curweap.AmmoType2).MaxAmount;
			vector2 amoffs = (0,0);

			Color tint = 0;
			if( (cur_ammo / clip_ammo) <= 0.4 ) 
			{
				double tintAlpha = sin(lowAmmoBlink * 5) * 160;
				tint = Color(int(tintAlpha), 255,8,8);
				lowAmmoBlink += deltaTime;
			}
			else
				lowAmmoBlink = 0;
			
			if( !haloweap.uses_battery && (curweap.AmmoType1 != curweap.AmmoType2) )
			{
				// Halo CE HUD only supports drawing ammo along the X axis.
				int xmax = clip_ammo < 20 ? max(haloweap.hudAmmo_xMax, haloweap.hudAmmo_yMax) : 20;
				double xshift = 0;
				
				for(int i = 0; i < clip_ammo; i++)
				{
					double iconAlpha = (cur_ammo--) > 0 ? 0.8 : 0.15;
					vector2 ammoOffs = (-80 + abs(haloweap.hudAmmo_xOffs*0.25), -20 + max(0,haloweap.hudAmmo_yOffs) );
					vector2 amdrawOffs = (amoffs.x * haloweap.hudAmmo_xSpacing, amoffs.y * haloweap.hudAmmo_ySpacing) * 1.25;
					amdrawoffs.x += xshift;
									
					HLSBS.DrawImage(
						haloweap.hudAmmo_graphic, 
						ampos + amdrawOffs + ammoOffs, 
						flags:weapDrawFlags, iconAlpha, (1.25,1.25) * haloweap.hudAmmo_scale, tint:tint
					);
										
					amoffs.x++;
					if(amoffs.x >= xmax) 
					{
						amoffs.x = 0;
						amoffs.y++;
						xshift += -0.25 * haloweap.hudAmmo_xSpacing;
					}
				}
			}
			else if(!skipAmmoDraw)
			{
				// Draw heat guage
				HLSBS.DrawImage(weapChargeBG, ampos + (38,-12), flags:weapDrawFlags, scale:(weapScale * 1.05,weapScale * 0.6));
				
				double heatWidth = haloweap.heat * 200;
				HLSBS.SetClipRect( (ampos.x - 120), (ampos.y - 32), heatWidth*weapScale*1.05, 64*weapScale*0.6, visual:false);
				HLSBS.DrawImage(weapChargeFG, ampos + (38,-12), flags:weapDrawFlags, scale:(weapScale * 1.05,weapScale * 0.6)); 
				HLSBS.ClearClipRect();
				
			}
		}
		
		// Draw grenades
		vector2 nadepos   = weapPos + (150,0);
		vector2 nadescale = (0.75, 0.75);
		
		let curNade = haloplr.activeGrenade;
		if(curNade && curNade.Amount > 0)
		{
			String nadeGraphic = String.Format("Graphics/UI/%s", curNade.hudIcon);
			HLSBS.DrawImage(nadeGraphic, nadepos + (-20,0), scale:nadescale);
			HLSBS.DrawString(fntHaloAmmo, String.Format("%d", curNade.Amount), nadepos+(5,-10), scale:(0.18,0.15) * 0.75);
			HLSBS.DrawImage(grenHousing, nadepos, flags:weapDrawFlags, scale:(weapScale,weapScale)); 
		}		
		
	}
	
	override void DrawBars()
	{
		base.DrawShieldRegen();
		
		vector2 shPos = (1700, 70);
		double shScale = 1.5;
		uint shDrawFlags = HLSBS.SS_NOASPECTCORRECTION;
		
		// Shields		
		string shOutline_Warn = "Graphics/UI/CE_HUD/Shields/CE Shield Outline Red.png";
		string shOutline_Norm = "Graphics/UI/CE_HUD/Shields/CE Shield Outline Blue.png";
		string shBlue  = "Graphics/UI/CE_HUD/Shields/CE Shield inside base.png";
		string shRed   = "Graphics/UI/CE_HUD/Shields/CE Shield inside OS1.png";
		string shGreen = "Graphics/UI/CE_HUD/Shields/CE Shield inside OS2.png";
		
		string shBackground = shBlue;
		string shForeground = shOutline_Norm;
		
		// Interpolate Shields
		if(curshields != haloplr.shields) 
		{
			double ispd = (haloplr.shields > curshields) ? 0.05 : 0.2;
			curshields = HaloMath.Lerp(curshields, haloplr.shields, ispd*deltatime);
		}
		if(curshields == 0) curshields = haloplr.shields;
		double shieldperc = curshields / haloplr.maxshields;
		
		// Setup shield parameters
		double shWarnAlpha = 0;
		if(shieldperc <= 0.1) shWarnAlpha = 0.5 + (sin(level.maptime * 15) * 0.5);
		
		if(shieldperc > 2.0) 
		{
			HLSBS.DrawImage(shRed, shPos, flags:shDrawFlags, scale:(shScale,shScale));
			shBackground = shGreen;
			shieldperc -= 2.0;
		}
		else if(shieldperc > 1.0) 
		{
			HLSBS.DrawImage(shBlue, shPos, flags:shDrawFlags, scale:(shScale,shScale));
			shBackground = shRed;
			shieldperc -= 1.0;
		}

		double shClipOffs = 292 * (1.0-shieldperc);
		HLSBS.DrawImage(shForeground, shPos, flags:shDrawFlags, scale:(shScale,shScale));
		HLSBS.DrawImage(shOutline_Warn, shPos, flags:shDrawFlags, alpha:shWarnAlpha, scale:(shScale,shScale));
		HLSBS.SetClipRect( (shPos.x - 125) + shClipOffs, shPos.y - 50, 292 - shClipOffs, 100);
		HLSBS.DrawImage(shBackground, shPos, flags:shDrawFlags, scale:(shScale,shScale));
		HLSBS.ClearClipRect();
		
		// Health
		double maxHP = haloplr.GetMaxHealth();
		double hpratio = haloplr.health / maxHP; 
		double hpScale = 1.35;
		int healthbars = clamp(ceil(hpratio * 9), 1, 25);
		
		string hbGFXBase = "Graphics/UI/CE_HUD/Health/CE_HB%d.png";
		string hbCurrent = String.Format(hbGFXBase, healthbars);
		
		HLSBS.DrawImage(hbCurrent, shPos + (-30,23), flags:shDrawFlags, scale:(hpScale, hpScale));
	}	
}
