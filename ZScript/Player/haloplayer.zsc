struct CortanaInfo
{
	Array<int> usedKeys;
}

class HaloPlayer : DoomPlayer
{
	// Misc
	Veh_Manager curvehicle;
	GrapplingHook grapple;
	WeaponPickupProxy pickuptarget;
	CortanaInfo cortana;
	Weapon NextWeapon;
	vector3 aimpos;
	double soundwait;
	double aimdist;
	bool shields_recharging;
	string class_desc;
	string feature_desc;
	FragGrenades activeGrenade;
	VehLight flashlight;
	
	// Sound effects
	Sound snd_ShieldRegen;
	
	// Door to be activated once animation finishes.
	Line pendingDoor; 
	string pendingDoorColor;
	
	// Shields
	double shield_regentime;
	double shield_regenrate;
	double shields;
	double maxshields;
	double regen_timer;
	double movebob;
	double viewoffs;
	
	// Weapon values
	double weap_yoffs;
	double xhair_lowpos;
	
	// UI 
	Color screen_color;
	double screen_fade;
	const FADE_RATE = 0.96;
		
	// CVar(s)
	transient CVar lowered_xhair;
	
	Property Shields : maxshields, shield_regentime, shield_regenrate;
	Property MovementBob : movebob;
	Property LowerCrosshairY : xhair_lowpos;
	Property MaxJumps : maxjumps;
	Property CanBunnyHop : enable_bhop;
	Property AirControl : aircontrol;
	Property SetupDashes : enable_dash, dashmax, dashpower, dashcooldown_time;
	Property EnableSlide : canslide;
	Property EnableGrapple : enable_grapple;
	Property Description : class_desc, feature_desc;
	Property ShieldRegenSound : snd_ShieldRegen;
	
	Default
	{
		Speed 1;
		Gravity 0.60;
		Player.JumpZ 9;
		Player.ViewHeight 41;		
		Player.SoundClass "Spartan";
		-DONTTRANSLATE;

		// UI
		Player.DisplayName "Spartan Template";
		HaloPlayer.Description "Template Spartan class.", "";
		
		// Vitals
		Health 45; 
		Player.MaxHealth 45;
		HaloPlayer.Shields 70, 3, 4; // 3 seconds to recharge, 4 seconds to max.
		
		// Inventory
		Player.StartItem "Halo_Magnum", 1;
		Player.StartItem "Halo_AR_Reserves", 120;
		
		// SFX
		HaloPlayer.ShieldRegenSound "Shield/Regenerate";
		
		// Movement
		HaloPlayer.LowerCrosshairY 60;
		HaloPlayer.MovementBob 0;
		HaloPlayer.AirControl 0.5;
		HaloPlayer.MaxJumps 1;
	}
	
	// Open locked door.
	void OpenPendingDoor()
	{
		if(!pendingDoor) return;
		pendingDoor.Activate(self, 1, SPAC_Use);
		pendingDoor = null;
	}
	
	virtual void OnMeleeHit(Actor victim) {}
	
	clearscope static string GetStatInfo(class<HaloPlayer> plrType)
	{
		let defs = GetDefaultByType(plrType);
		return String.Format(
		(
			"Health: %d\n"
			"Shields: %d\n"
			"Regen Speed: %ds\n"
			"Regen Cooldown: %ds\n"
		), defs.maxhealth, defs.maxshields, defs.shield_regenrate, defs.shield_regentime );
	}
	
	override void BeginPlay()
	{
		regen_timer = shield_regentime*35.;
		shields = maxshields;
		super.BeginPlay();
	}
	
	void SendHUDMessage(String msg)
	{
		// Feels like hax but, kinda clean ngl.
		Inventory.PrintPickupMessage(CheckLocalView(), msg);
	}
	
	FragGrenades nextGrenade(bool select, bool skipDepleted = true, bool forceSwitch = false)
	{
		int curSlot = -1;
		FragGrenades nade = NULL;
		if(activeGrenade) curSlot = activeGrenade.nadeSlot + 1;
		
		let curWeap = HaloGun(player.ReadyWeapon);
		bool canSwap = (curWeap && !curWeap.handsbusy) || forceSwitch;
		if(!canSwap) return activeGrenade;
		
		while(!nade)
		{
			bool hasNade = false;
			for(let item = Inv; item; item = item.Inv)
			{
				let curNade = FragGrenades(item);
				if( !curNade || curNade == activeGrenade ||
					(curNade.amount <= 0 && skipDepleted && curSlot >= 0) )
					continue;
					
				hasNade = true;
				if( curSlot < 0 || (curNade.nadeSlot == curSlot) ) 
				{
					nade = curNade;
					break;
				}
			}
			curSlot++;
			if(curSlot > 9) curSlot = 0;
			if(!hasNade) break;
		}
		
		if(select) activeGrenade = nade;
		return nade;
	}
	
	override void Tick()
	{
		// Flashlight stuff
		if(!flashlight) 
		{
			flashlight = VehLight.Attach( self, intense_in_out:(350,16,40), offset:(10,0,0) );
			flashlight.active = false;
		}
		
		// In vehicle?
		curvehicle = Veh_Manager(FindInventory("Veh_Manager"));
					
		// Don't do stuff when dead.
		if(health <= 0 || !player) 
		{
			A_StopSound(CHAN_7);
			super.Tick();
			return;
		}
		
		// No valid grenade?
		if(!activeGrenade || activeGrenade.amount <= 0) nextGrenade(true);
		
		// Get CVar(s)
		if(!lowered_xhair)
			lowered_xhair = CVar.GetCVar("halodoom_loweredcrosshair", player);
		
		// Processes lowered crosshair differences.
		double defvz = default.viewheight;
		if(lowered_xhair.GetBool())
		{
			SetViewHeight(defvz * 1.2);
			weap_yoffs = 20;
		}
		else
		{
			SetViewHeight(defvz);
			weap_yoffs = 0;
		}
			
		// Used for timing certain sound fx.
		if(soundwait) soundwait--;
	
		// Shield Regen
		double shregentime = shield_regentime*35.;
		
		uint sndflags = CHANF_LOOPING|CHANF_MAYBE_LOCAL;
		if(regen_timer < shregentime)
		{
			if(shields <= 0) 
				A_StartSound("Shield/Warning", CHAN_6, flags:sndflags);
			else if(shields <= maxshields*0.25) 
				A_StartSound("Shield/Low", CHAN_6, flags:sndflags);
		}
		if(regen_timer < shregentime) 
		{	
			regen_timer += 1;
			// Useful for overshields to not regenerate.
			if(shields > maxshields) regen_timer = shregentime;
		}
		regen_timer = clamp(regen_timer, -shregentime, shregentime);
		if(regen_timer >= shregentime && shields < maxshields) 
		{
			double recharge_perc = (shields / maxshields);
			if(!shields_recharging)
			{
				A_StartSound(snd_ShieldRegen, CHAN_5, flags:CHANF_MAYBE_LOCAL, startTime:recharge_perc*3.0);
				shields_recharging = true;
			}
			A_SoundVolume(CHAN_5, (1.0 - recharge_perc) + 0.1);
			shields += maxshields/(shield_regenrate*35.);
			shields = clamp(shields, 0, maxshields);
			A_StopSound(CHAN_6);
		}
		if(shields >= maxshields)
		{
			shields_recharging = false;
			A_StopSound(CHAN_5);
		}
		
		// Aim Assist
		if(halodoom_doaimassist) DoAimAssist();
		
		// Deal with lowered crosshair awkwardness...
		let weap = HaloGun(player.ReadyWeapon);
		bool lowc = lowered_xhair.GetBool();
		double aimheight = lowc ? 5 : 0;
		if(weap && weap.zoomed && lowc) aimheight = 4.0 * weap.FOVScale;
		
		// Get Distance under crosshair.
		FLineTraceData lt;
		LineTrace(angle, 1024*1024, pitch+aimheight, 0, player.viewz-pos.z, 0, data:lt);
		
		aimdist = lt.Distance / UNIT_METER; 
		aimpos = lt.HitLocation;
		
		// Update next weapon.
		let wnext = PickNextWeapon();
		if( player.ReadyWeapon != wnext ) NextWeapon = wnext;
		
		// Screen flash colors
		screen_fade *= FADE_RATE;
		
		super.Tick();
	}
	
	override int DamageMobJ(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		// Get real damage amount, taking into account modified damage.
		double dmg = GetModifiedDamage(mod, damage, true);
		double truedamage = dmg / GAMEPLAY_DAMAGEMOD;
		
		if( bInvulnerable || player.cheats & (CF_GODMODE|CF_GODMODE2) ) return 0;
		
		if(shields > 0)
		{
			regen_timer = 0;
			shields -= truedamage;
			A_StopSound(CHAN_5);
			A_StartSound("Shield/TakeDamage",flags:CHANF_NOSTOP);
			if(shields <= 0) 
			{	
				A_StartSound("Shield/Explode",flags:CHANF_NOSTOP);
				double truedmg = abs(shields);
				shields = 0;
				return super.DamageMobJ(inflictor, source, ceil(truedmg), mod, flags | DMG_FORCED, angle);
			}
			return 0;
		}
		return super.DamageMobJ(inflictor, source, ceil(truedamage), mod, flags | DMG_FORCED, angle);
	}
	
	clearscope bool CheckCrosshairLowered()
	{
		// Safe way of checking lowered_xhair CVar.
		return lowered_xhair && lowered_xhair.GetBool();
	}
	
	void DoAimAssist(double strength = 0.10)
	{
		// Check for aim assist cheat.
		let evs = HaloDoom_Events(EventHandler.Find("HaloDoom_Events"));
		
		// Do not apply if not using a controller.
		if(using_controller || (evs && evs.alwaysautoaim))
		{
			// Get target under aim.
			let act = AimTarget();
			if(!act || act is "VehBase" || act is "VehPart") return;
			
			// Gather pitch and angular difference and interpolate
			// aim to target.
			vector3 aimpos = (act.pos.x, act.pos.y, act.pos.z + act.height/2.);
			vector3 frompos = (pos.x, pos.y, player.viewz - (weap_yoffs * 1.2));
			vector3 diffs = level.SphericalCoords(frompos, aimpos, (angle, pitch));
			angle -= diffs.x * strength;
			pitch -= diffs.y * (strength * 0.25);
		}
	}
	
	void SetViewHeight(double val)
	{
		viewheight = player.viewheight = (val + viewoffs);
	}
	
	override void CalcHeight()
	{
		super.CalcHeight();
		player.viewz = pos.Z + player.viewheight + (player.bob * clamp(movebob, 0. , 1.5)); 
		if (Floorclip && player.playerstate != PST_DEAD && pos.Z <= floorz) player.viewz -= Floorclip;
		if (player.viewz > ceilingz - 4) player.viewz = ceilingz - 4;
		if (player.viewz < floorz + 4) player.viewz = floorz + 4;
	}
	
	States
	{
		Spawn:
			HALO A -1;
			Loop;
		See:
			HALO ABCD 4 A_JumpIf(player.vel.length() < 1, "Spawn");
			Loop;
		Missile:
			HALO E 12;
			Goto Spawn;
		Melee:
			HALO F 6 BRIGHT;
			Goto Missile;
		Pain:
			HALO G 4;
			HALO G 4 A_Pain;
			Goto Spawn;
		Death:
			HALO H 10;
			HALO I 10 A_PlayerScream;
			HALO J 10 A_NoBlocking;
			HALO KLM 10;
			HALO N -1;
			Stop;
		XDeath:
			HALO O 5;
			HALO P 5 A_XScream;
			HALO Q 5 A_NoBlocking;
			HALO RSTUV 5;
			HALO W -1;
			Stop;
			
		GunLightning:
			TNT1 A 0 
			{
				A_OverlayFlags(OverlayID(), PSPF_RENDERSTYLE | PSPF_ALPHA, true);
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				
				/*let curPSprite = player.GetPSprite(OverlayID());
				if(!(GetAge() % 2)) 
					invoker.GunLightningFlash = !invoker.GunLightningFlash;
				curPSprite.frame = invoker.GunLightningFlash ? 1 : 9;*/
			}
			BIRI B 1;
			TNT1 A 0
			{
				let curPSprite = player.GetPSprite(OverlayID());
				curPSprite.alpha *= 0.25;
				
				if(curPSprite.alpha <= 0) 
					return ResolveState(null);
				return ResolveState("GunLightning");
			}
		stop;
	}
}