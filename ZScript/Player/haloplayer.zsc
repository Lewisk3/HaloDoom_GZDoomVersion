struct CortanaInfo
{
	Array<int> usedKeys;
}

class HaloPlayer : DoomPlayer
{
	// Misc
	Veh_Manager curvehicle;
	GrapplingHook grapple;
	WeaponPickupProxy pickuptarget;
	CortanaInfo cortana;
	SpartanOverlay shieldOverlay;
	
	Actor aimActor_nearest; // Actor closest to aim;
	vector3 aimActor_anglesTo; // Angles to closest aimed at actor.
	vector3 aimActor_pos;
	vector3 lookAtCoord;
	bool lookingAtCoord; // If true, freeze the player and look towards `lookAtCoord`
	Actor aimActor;
	vector3 aimpos;
	double soundwait;
	double aimdist;
	bool shields_recharging;
	string class_desc;
	string feature_desc;
	string floorLiquidType;
	FragGrenades activeGrenade;
	VehLight flashlight;
	PowerHaloVisor visor;
	int invulnTics;
	double healthDecay;
	
	// Sound effects
	Sound snd_ShieldRegen;
	const CHAN_VOICELINES = 69;
	const CHAN_HEALTHEFFECTS = 72;
	
	// Door to be activated once animation finishes.
	transient Line pendingDoor; 
	string pendingDoorColor;
	
	// Shields
	double shield_regentime;
	double shield_regenrate;
	double shields;
	double maxshields;
	double regen_timer;
	double movebob;
	double viewoffs;
	double shield_snd_volume;
	double radarRange;
	
	// Weapon values
	double weap_yoffs;
	double xhair_lowpos;
	
	// UI 
	Color screen_color;
	double screen_fade;
	string overlay_img;
	bool drawWeaponInfo;
	const FADE_RATE = 0.96;
	
	// Quaternions
	Quat ViewRotation;
		
	// CVar(s)
	transient CVar lowered_xhair;
	
	Property Shields : maxshields, shield_regentime, shield_regenrate;
	Property MovementBob : movebob;
	Property LowerCrosshairY : xhair_lowpos;
	Property MaxJumps : maxjumps;
	Property CanBunnyHop : enable_bhop;
	Property AirControl : aircontrol;
	Property SetupDashes : enable_dash, dashmax, dashpower, dashcooldown_time;
	Property EnableSlide : canslide;
	Property EnableGrapple : enable_grapple;
	Property Description : class_desc, feature_desc;
	Property ShieldRegenSound : snd_ShieldRegen;
	Property _ShieldSNDVolume : shield_snd_volume;
	Property RadarRange : radarRange;
	
	// Apply damage modifier based on skill	
	static const double skillDamage[] =
	{
		0.5, // Easy
		0.7, // Normal
		1.0, // Heroic
		1.20, // Legendary
		1.50 // Mythic
	};
	
	Default
	{
		Speed 1;
		Gravity 0.60;
		Player.JumpZ 9;
		Player.ViewHeight 41;		
		Player.SoundClass "Spartan";
		-DONTTRANSLATE;
		YScale 1.10;
		DamageFactor "Burn", 0.5;

		// UI
		Player.DisplayName "Spartan Template";
		HaloPlayer.Description "Template Spartan class.", "";
		HaloPlayer._ShieldSNDVolume 1.0;
		HaloPlayer.RadarRange 800;
		
		// Vitals
		Health 45; 
		Player.MaxHealth 45;
		HaloPlayer.Shields 70, 3, 4; // 3 seconds to recharge, 4 seconds to max.
		
		// Inventory
		Player.StartItem "";
		
		// SFX
		HaloPlayer.ShieldRegenSound "Shield/Regenerate";
		
		// Movement
		HaloPlayer.LowerCrosshairY 60;
		HaloPlayer.MovementBob 0;
		HaloPlayer.AirControl 0.5;
		HaloPlayer.MaxJumps 1;
	}
	
	override bool OnGiveSecret(bool printmsg, bool playsound) 
	{ 
		SendHUDMessage("Found a secret area.");
		A_StartSound("Halo/SecretFound", CHAN_AUTO);
		return false; 
	}
	
	// Open locked door.
	void OpenPendingDoor()
	{
		if(!pendingDoor) return;
		pendingDoor.Activate(self, 1, SPAC_Use);
		pendingDoor = null;
	}
	
	static bool IsGameType(string types)
	{
		let gt = HaloMath.getCurrentGameType();
		return gt.defName ~== types;
	}
	
	virtual void OnEnemyKilled(Actor victim)
	{
		if(!player) return;
		
		let cv_voicelines = CVar.GetCVar("halodoom_spartanvoicelines", player);
		if(!cv_voicelines || !cv_voicelines.getBool()) return;
		
		String SNDGender = "";
		switch(player.GetGender())
		{
			case GENDER_FEMALE:
				SNDGender = "F";
			break;
				
			/* TODO: Sounds for these.
			case GENDER_OBJECT
				SNDGender = "O";
			break;
			case GENDER_NEUTRAL
				SNDGender = "N";
			break;
			*/
			
			default:
			case GENDER_MALE:
				SNDGender = "M";
			break;
		}
		
		int res = random[OnelinersRNG](0,100);
		if( res >= 70 && !IsActorPlayingSound(CHAN_VOICELINES) )
		{
			string SNDBase = String.Format("Halo/Spartan/%s/GotKill", SNDGender);
			string SNDType = "";
			
			if(victim is "Revenant")
				SNDType = "Revenant";
			else if(victim.bSHADOW || victim.GetRenderStyle() == STYLE_OPTFUZZY)
				SNDType = "Spectre";
		
			string SNDFinal = (SNDType != "") ? String.Format("%s_%s", SNDBase, SNDType) : SNDBase;
			// console.printf("Final %s", SNDFinal); 
			A_StartSound(SNDFinal, CHAN_VOICELINES, CHANF_NOPAUSE|CHANF_NOSTOP);
		}
	}
	
	// Called when the player initially spawns, sets up spawn items.
	virtual void SetupInventory()
	{
		GiveInventory("DoHelmetAnimation", 1);
		let gt = HaloMath.getCurrentGameType();
		gt.GiveLoadout(self);
				
		/*
		if(IsGameType("HL1"))
		{
			GiveInventory("Halo_MA5B", 1);
			GiveInventory("Halo_Magnum", 1);
			GiveInventory("Halo_AR_Reserves", 120);
			GiveInventory("Halo_Magnum_Reserves", 36);
		}
		else if(IsGameType("HL2"))
		{
			GiveInventory("Halo_BattleRifle", 1);
			GiveInventory("Halo_Sidekick", 1);
			GiveInventory("Halo_BAR_Reserves", 90);
			GiveInventory("Halo_Sidekick_Reserves", 48);
		}
		else if(IsGameType("MSX"))
		{
			GiveInventory("Halo_MA5B", 1);
			GiveInventory("Halo_Sidekick", 1);
			GiveInventory("Halo_AR_Reserves", 120);
			GiveInventory("Halo_Sidekick_Reserves", 36);
		}
		else if(IsGameType("StarWars"))
		{
			GiveInventory("Halo_PlasmaRifle", 1);
			GiveInventory("Halo_PlasmaPistol", 1);
		}
		else if(IsGameType("SpartanOverkill"))
		{
			GiveInventory("Halo_Magnum", 1);
			GiveInventory("Halo_Magnum_Reserves", 36);
			GiveInventory("Halo_Bulldog", 1);
			GiveInventory("Halo_Bulldog_Reserves", 20);
			GiveInventory("plasmagrenades", 4);
			GiveInventory("fraggrenades", 4);
		}
		else
		{
			GiveInventory("Halo_AssaultRifle", 1);
			GiveInventory("Halo_Sidekick", 1);
			GiveInventory("Halo_AR_Reserves", 120);
			GiveInventory("Halo_Sidekick_Reserves", 48);
		}
		*/
	}
	
	virtual bool CheckCanMelee()
	{
		return true;
	}
	virtual void OnMeleeHit(Actor victim) 
	{
		for(let item = Inv; item.Inv; item = item.Inv)
		{
			let hpwr = HaloPowerup(item);
			if(!hpwr) continue;
			
			hpwr.OnMeleeHit(victim);
		}
	}
	
	clearscope static string GetStatInfo(class<HaloPlayer> plrType)
	{
		let defs = GetDefaultByType(plrType);
		return String.Format(
		(
			"Health: %d\n"
			"Shields: %d\n"
			"Regen Speed: %ds\n"
			"Regen Cooldown: %ds\n"
		), defs.maxhealth, defs.maxshields, defs.shield_regenrate, defs.shield_regentime );
	}
	
	override void BeginPlay()
	{
		regen_timer = shield_regentime*35.;
		shields = maxshields;
		SetupInventory();
		ViewRotation = Quat.FromAngles(angle, pitch, roll);
		
		super.BeginPlay();
	}
	
	void SendHUDMessage(String msg)
	{
		// Feels like hax but, kinda clean ngl.
		Inventory.PrintPickupMessage(CheckLocalView(), msg);
	}
	
	FragGrenades nextGrenade(bool select, bool skipDepleted = true, bool forceSwitch = false)
	{
		int curSlot = -1;
		FragGrenades nade = NULL;
		if(activeGrenade) curSlot = activeGrenade.nadeSlot + 1;
		
		let curWeap = HaloGun(player.ReadyWeapon);
		bool canSwap = (curWeap && !curWeap.handsbusy) || forceSwitch;
		if(!canSwap) return activeGrenade;
		
		while(!nade)
		{
			bool hasNade = false;
			for(let item = Inv; item; item = item.Inv)
			{
				let curNade = FragGrenades(item);
				if( !curNade || curNade == activeGrenade ||
					(curNade.amount <= 0 && skipDepleted && curSlot >= 0) )
					continue;
					
				hasNade = true;
				if( curSlot < 0 || (curNade.nadeSlot == curSlot) ) 
				{
					nade = curNade;
					break;
				}
			}
			curSlot++;
			if(curSlot > 9) curSlot = 0;
			if(!hasNade) break;
		}
		
		if(select) activeGrenade = nade;
		return nade;
	}
	
	override void Tick()
	{	
		if(!player) 
		{
			super.Tick();
			return;
		}
		
		if( (health > default.health) && halodoom_overhealthdecay ) 
		{
			healthDecay += 0.065;
			if(healthDecay >= 1.0)
			{
				health--;
				player.health = health;
				healthDecay = 0;
			}
		}
		else
		{
			healthDecay = 0;
		}
		
		if(lookingAtCoord)
		{
			player.cheats |= CF_TOTALLYFROZEN;
			player.cheats |= CF_INTERPVIEW;
		
			vector3 camPos = (pos.xy, player.viewz);
			vector3 dir = level.vec3diff(camPos, lookAtCoord);
			if(dir.Length() > 0)
			{
				dir = dir.Unit();
				vector2 lookCoords = (
					atan2(dir.y, dir.x),
					-asin(dir.z)
				);

				let curView = Quat.FromAngles(angle, pitch, roll);
				let desiredView = Quat.FromAngles(lookCoords.x, lookCoords.y, 0);
				let toView = Quat.SLerp(curView, desiredView, 0.2);
			
				// Set angles to new look direction
				vector3 eulerAngles = HaloMath.GetEuler(desiredView);
				A_SetAngle(eulerAngles.x, SPF_Interpolate);
				A_SetPitch(eulerAngles.y, SPF_Interpolate);
				// A_SetRoll(eulerAngles.z, SPF_Interpolate);
			}
		}
		
		bool predicting = (player.cheats & CF_PREDICTING); 
		if(predicting)
		{
			super.Tick();
			return;
		}
		
		// Low health effects
		double hpratio = max(health, player.health) / double(GetMaxHealth()); 
		int healthbars = clamp(ceil(hpratio * 9), 1, 25);
		if(healthbars <= 3 && min(health, player.health) > 0)
		{
			A_StartSound("Halo/Spartan/LowHealthLoop", CHAN_HEALTHEFFECTS, CHANF_LOOPING);
		}
		else
		{
			A_StopSound(CHAN_HEALTHEFFECTS);
		}
		
		// Get floor liquid
		let splashDict = HaloDoom_Events.GetSplashData();
		string floorpicName = TexMan.GetName(floorpic);
		floorLiquidType = splashDict.At(floorpicName);
		
		// Clean up stuff on death.
		if(player.playerstate == PST_DEAD) 
		{
			if(flashlight) flashlight.Destroy();
		}
		
		// Flashlight stuff
		if(!flashlight) 
		{
			flashlight = VehLight.Attach( self, intense_in_out:(350,16,40), offset:(10,0,0) );
			flashlight.active = false;
		}
		
		// Find visor
		if(!visor)
		{
			visor = PowerHaloVisor(FindInventory("PowerHaloVisor"));
		}
		
		// Fix for SetupInventory not selecting a Weapon by default.
		if( !!FindInventory("HaloGun", true) && !player.ReadyWeapon )
		{
			let weap = PickNextWeapon();
			if(weap) weap.Use(false);
		}
		
		// Overlay stuff
		if(!shieldOverlay) 
			shieldOverlay = SpartanOverlay.Attach(self);
		else
			shieldOverlay.Update(shields, maxshields);
		
		// In vehicle?
		curvehicle = Veh_Manager(FindInventory("Veh_Manager"));
					
		// Don't do stuff when dead or a voodoo.
		if( health <= 0 || (!player || !player.mo || player.mo != self) ) 
		{
			A_StopSound(CHAN_7); // Various Weapon loop sound effects.
			A_StopSound(ShieldProcessor.CHAN_SHIELDLOOP);
			A_StopSound(ShieldProcessor.CHAN_SHIELDWARN);
			super.Tick();
			return;
		}
		
		// No valid grenade?
		if(!activeGrenade || activeGrenade.amount <= 0) nextGrenade(true);
		
		// Get CVar(s)
		if(!lowered_xhair)
			lowered_xhair = CVar.GetCVar("halodoom_loweredcrosshair", player);
		
		// Processes lowered crosshair differences.
		double defvz = default.viewheight;
		if(lowered_xhair.GetBool())
		{
			SetViewHeight(defvz * 1.2);
			weap_yoffs = 20;
		}
		else
		{
			SetViewHeight(defvz);
			weap_yoffs = 0;
		}
			
		// Used for timing certain sound fx.
		if(soundwait) soundwait--;
		
		// Count-down invuln tics.
		if(invulnTics > 0) invulnTics--;
	
		// Shield Regen
		double shregentime = shield_regentime*35.;
		
		uint sndflags = CHANF_LOOPING|CHANF_MAYBE_LOCAL;
		if(regen_timer < shregentime)
		{
			if(shields <= 0) 
				A_StartSound("Shield/Warning", ShieldProcessor.CHAN_SHIELDLOOP, flags:sndflags, volume:shield_snd_volume);
			else if(shields <= maxshields*0.25) 
				A_StartSound("Shield/Low", ShieldProcessor.CHAN_SHIELDLOOP, flags:sndflags, volume:shield_snd_volume);
			else
				A_StopSound(ShieldProcessor.CHAN_SHIELDLOOP);
		} else if(shields > (maxshields*0.25))
			A_StopSound(ShieldProcessor.CHAN_SHIELDLOOP);
			
		if(regen_timer < shregentime) 
		{	
			regen_timer += 1;
			// Useful for overshields to not regenerate.
			if(shields > maxshields) regen_timer = shregentime;
		}
		regen_timer = clamp(regen_timer, -shregentime, shregentime);
		if(regen_timer >= shregentime && shields < maxshields) 
		{
			double recharge_perc = (shields / maxshields);
			if(!shields_recharging)
			{
				A_StartSound(snd_ShieldRegen, ShieldProcessor.CHAN_SHIELDWARN, flags:CHANF_MAYBE_LOCAL, startTime:recharge_perc);
				shields_recharging = true;
			}
			A_SoundVolume(ShieldProcessor.CHAN_SHIELDWARN, (1.0 - recharge_perc) + 0.1);
			shields += maxshields/(shield_regenrate*35.);
			shields = clamp(shields, 0, maxshields);
			A_StopSound(ShieldProcessor.CHAN_SHIELDLOOP);
		}
		if(shields >= maxshields)
		{
			shields_recharging = false;
			A_StopSound(ShieldProcessor.CHAN_SHIELDWARN);
		}
		
		// Aim Assist
		if(halodoom_doaimassist) DoAimAssist();
		
		// Deal with lowered crosshair awkwardness...
		let weap = HaloGun(player.ReadyWeapon);
		bool lowc = lowered_xhair.GetBool();
		double aimheight = lowc ? 5 : 0;
		if(weap && weap.zoomed && lowc) aimheight = 4.0 * weap.FOVScale;
		
		// Get Distance under crosshair.
		FLineTraceData lt;
		LineTrace(angle, 1024*1024, pitch+aimheight, flags:0, player.viewz-pos.z, 0, data:lt);
		
		aimdist = lt.Distance / UNIT_METER; 
		aimpos = lt.HitLocation;
		aimActor = lt.HitActor;
				
		// Screen flash colors
		screen_fade *= FADE_RATE;
		
		// Find closest aimable actor.
		super.Tick();

		Actor act;
		double p = pitch+aimheight;
		vector3 fromPos = (
			cos(angle) * cos(p),
			sin(angle) * cos(p),
			-sin(p)
		) * (aimActor_nearest ? (aimActor_anglesTo.z) : 10);
		fromPos = level.vec3offset(fromPos, (pos.xy, player.viewz));
	
		int closestAim = int.max;
		aimActor_nearest = null;
		LookExParams look;
		look.FOV = 90;

		let it = BlockThingsIterator.Create(self, 2048);
		while(it.Next())
		{	
			let act = it.Thing; 
			if( !act.bSHOOTABLE || act == self || !isVisible(act, false, look) || !act.bISMONSTER ) continue;
			vector3 toPos = (act.pos.xy, act.pos.z + (act.height*0.5));
			vector3 toAngles = level.SphericalCoords((pos.xy, player.viewz), toPos, (angle,pitch));
			if(toAngles.z > 10000) continue;

			double angTo = toAngles.x;
			double pitTo = toAngles.y;
			double aimDist = abs(angTo) + abs(pitTo) + (toAngles.z*0.25);
			if(aimDist < closestAim)
			{
				closestAim = aimDist;
				aimActor_nearest = act;
				aimActor_pos = fromPos;
				aimActor_anglesTo.x = angTo;
				aimActor_anglesTo.y = pitTo;
				aimActor_anglesTo.z = toAngles.z;
			}
		}
	}
	
	override int DamageMobJ(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		// Don't take damage if invuln tics are active.
		if(invulnTics > 0 || !player) return 0;
		
		double dmg = GetModifiedDamage(mod, damage, true);
		if(shields > 0)
			dmg = HaloProjectile.ApplyShieldDamage(dmg, HaloProjectile(inflictor), mod == 'Headshot');
		
		// Get real damage amount, taking into account modified damage.		
		double truedamage = dmg * max(0.01, skillDamage[min(4, skill)] * halodoom_damagetakenmod);
		
		if( bInvulnerable || player.cheats & (CF_GODMODE|CF_GODMODE2) ) return 0;
		
		if(shields > 0)
		{
			if(mod == 'hitscan') truedamage *= 0.5;
			regen_timer = 0;
			shields -= truedamage;
			shields_recharging = false;
			A_StopSound(ShieldProcessor.CHAN_SHIELDWARN);
			A_StartSound("Shield/TakeDamage",flags:CHANF_NOSTOP);
			if(shields <= 0) 
			{	
				A_StartSound("Shield/Explode",flags:CHANF_NOSTOP);
				double truedmg = abs(shields);
				shields = 0;
				
				if(mod != 'plasma') // Shield bleed damage, so long as source isn't plasma.
					return super.DamageMobJ(inflictor, source, ceil(truedmg), mod, flags | DMG_FORCED, angle);
			}
			return 0;
		}
		return super.DamageMobJ(inflictor, source, ceil(truedamage), mod, flags | DMG_FORCED, angle);
	}
	
	clearscope bool CheckCrosshairLowered()
	{
		// Safe way of checking lowered_xhair CVar.
		return lowered_xhair && lowered_xhair.GetBool();
	}
	
	void DoAimAssist(double strength = 0.10)
	{
		// Check for aim assist cheat.
		let evs = HaloDoom_Events(EventHandler.Find("HaloDoom_Events"));
		
		// Do not apply if not using a controller.
		if(using_controller || (evs && evs.alwaysautoaim))
		{
			// Get target under aim.
			let act = AimTarget();
			if(!act || act is "VehBase" || act is "VehPart") return;
			
			// Gather pitch and angular difference and interpolate
			// aim to target.
			vector3 aimpos = (act.pos.x, act.pos.y, act.pos.z + act.height/2.);
			vector3 frompos = (pos.x, pos.y, player.viewz - (weap_yoffs * 1.2));
			vector3 diffs = level.SphericalCoords(frompos, aimpos, (angle, pitch));
			angle -= diffs.x * strength;
			pitch -= diffs.y * (strength * 0.25);
		}
	}
	
	void SetViewHeight(double val)
	{
		viewheight = player.viewheight = (val + viewoffs);
	}
	
	void LookAtPoint(vector3 point)
	{
		lookingAtCoord = true;
		lookAtCoord = point;
	}
	void StopLookingAtPoint()
	{
		player.cheats &= ~CF_TOTALLYFROZEN;
		lookingAtCoord = false;
	}
	
	override void CalcHeight()
	{
		super.CalcHeight();
		
		double bobAngle;
		double bob;
		if (vel.length() ~== 0)
		{
			if (player.health > 0)
			{
				bobAngle = Level.maptime / (120 * TICRATE / 35.) * 360.;
				bob = player.GetStillBob() * sin(bobAngle);
			}
			else
			{
				bob = 0;
			}
		}
		else
		{
			bobAngle = Level.maptime / (20 * TICRATE / 35.) * 360.;
			bob = player.bob * sin(bobAngle) * (waterlevel > 1 ? 0.25f : 0.5f);
		}
		
		player.viewz = pos.Z + player.viewheight + (bob * clamp(movebob, 0. , 1.5)); 
		if (Floorclip && player.playerstate != PST_DEAD && pos.Z <= floorz) player.viewz -= Floorclip;
		if (player.viewz > ceilingz - 4) player.viewz = ceilingz - 4;
		if (player.viewz < floorz + 4) player.viewz = floorz + 4;
	}
	
	override vector2 BobWeapon(double ticfrac)
	{
		if(player.onground) return super.BobWeapon(ticfrac);
		return (0,0);
	}
	
	States
	{
		Spawn:
			HALO A -1;
			Loop;
		See:
			HALO ABCD 4 A_JumpIf(player.vel.length() < 1, "Spawn");
			Loop;
		Missile:
			HALO E 12;
			Goto Spawn;
		Melee:
			HALO F 6 BRIGHT;
			Goto Missile;
		Pain:
			HALO G 4;
			HALO G 4 A_Pain;
			Goto Spawn;
		Death:
			HALO H 10;
			HALO I 10 A_PlayerScream;
			HALO J 10 A_NoBlocking;
			HALO KLM 10;
			HALO N -1;
			Stop;
		XDeath:
			HALO O 5;
			HALO P 5 A_XScream;
			HALO Q 5 A_NoBlocking;
			HALO RSTU 5;
			HALO V -1;
			Stop;
			
		GunLightning:
			TNT1 A 0 
			{
				A_OverlayFlags(OverlayID(), PSPF_RENDERSTYLE | PSPF_ALPHA, true);
				A_OverlayRenderStyle(OverlayID(), STYLE_Add);
				
				/*let curPSprite = player.GetPSprite(OverlayID());
				if(!(GetAge() % 2)) 
					invoker.GunLightningFlash = !invoker.GunLightningFlash;
				curPSprite.frame = invoker.GunLightningFlash ? 1 : 9;*/
			}
			BIRI B 1;
			TNT1 A 0
			{
				let curPSprite = player.GetPSprite(OverlayID());
				curPSprite.alpha *= 0.25;
				
				if(curPSprite.alpha <= 0) 
					return ResolveState(null);
				return ResolveState("GunLightning");
			}
		stop;
	}
}

class SpartanOverlay : Actor
{	
	Actor source;
	double prevShields;

	Default
	{
		RenderStyle "Translucent";
		Translation "0:255=@65[10,8,240]";
		Alpha 0.5;
		Scale 1.0;
	}
	
	static SpartanOverlay Attach(Actor src)
	{
		let sov = SpartanOverlay(Spawn("SpartanOverlay", src.pos));
		if(sov)
		{
			sov.source = src;
		}
		return sov;
	}
	
	virtual void Update(double curshields, double maxshields)
	{
		
		if(curshields < maxshields && curshields > 0)
		{
			alpha = 1.0 - (curshields / maxshields);
		}
		else
		{
			alpha = 0;
		}
		
		if(prevShields > 0 && curshields <= 0)
		{
			// Shield broke
			GiveInventory("ShieldLightningAnimator", 1);
		}
		
		prevShields = curshields;
	}
	
	override void Tick()
	{
		if(!source) 
		{
			Destroy();
			return;
		}
		
		// Make invisible for source, if source is player.
		let localplr = players[consoleplayer].mo;
		if(localplr == source)
		{
			bInvisible = (localplr.player.cheats & CF_CHASECAM) ? false : true;
		}
		
		// Copy source values.
		SetOrigin(source.pos, true);
		A_SetScale(source.Scale.X, source.Scale.Y);
		angle = source.angle;
		pitch = source.pitch;
		roll  = source.roll;
		Sprite = source.Sprite;
		Frame = source.Frame;
		Tics = source.Tics;
	}
	
	States
	{
		Spawn:
			"####" "#" -1;
		stop;
	}
}
class ShieldLightningAnimator : CustomInventory
{
	virtual void DoLightning(vector3 atpos, double amt = 4)
	{
		vector2 view;
		for(int i = 0; i < amt; i++)
		{
			view.x = angle + frandom[ShieldLightning](-180,180);
			view.y = pitch + frandom[ShieldLightning](-60,60);
			BiriBiri.DoLightning(atpos, view, dist:25, 0.5, 20.0, 10.0, 30, 0);
		}
	}
	
	virtual void DoParticles(Actor src, double amt = 5, double zoffs = 0, Color pcol = 0xFF0a08f0)
	{
		for(int i = 0; i < amt; i++)
		{
			double ang = frandom[ShieldParticles](0,360);
			double pit = frandom[ShieldParticles](-45,45);
			vector3 rdir = (
				cos(ang),
				sin(ang),
				-sin(pit)
			) * frandom[ShieldParticles](4,16);
			
			src.A_SpawnParticle(
				pcol, SPF_FULLBRIGHT, 35, 3.0, ang,
				0,0, zoffs, rdir.x,rdir.y,rdir.z,0,0,0,
				frandom[ShieldParticles](0.8,1.0), 0.025
			);
		}
	}
		

	States
	{
		Pickup:
			TNT1 AAAAAAAAAAAAAAAAAA 4
			{
				vector3 atpos = (pos.xy, pos.z + (height));
				if(player) atpos.z = player.viewz;
				atpos.x += frandom[ShieldFX](-1,1) * 30;
				atpos.y += frandom[ShieldFX](-1,1) * 30;
				atpos.z += frandom[ShieldFX](0,1) * 20;
				invoker.DoLightning(atpos, 2);
				invoker.DoParticles(self, zoffs:height);
			}
		stop;
	}
}
