extend class HaloPlayer
{
	// Movement constants
	const GNDMAX   = 14;
	const GNDACCEL = 85;
	const GNDFRIC  = 7.0;
	const DODGECOOLDOWN = 18;
	const DOOMGNDACCEL = 1.25;
	const DOOMGNDFRIC = 0.95;
	const CHAN_SPACEJETS = 17;
	const CHAN_SPACEJETLOOP = 18;
	
	const BT_DASH = BT_USER3;
	const BT_GRAPPLE = BT_USER4;
	const SLIDE_TICS = 20;
	const SLIDE_COOL = 35;
	
	const AIRMAX     = 10;
	const AIRACCEL   = 40;
	
	bool doomermovement;
	bool spacemovement; // No gravity movement
	bool doJetpackMovement; // Different air movement code.
	bool jumpdodging; // On if jumpdodge key is being pressed.
	
	// Switches
	bool enable_grapple;
	bool enable_bhop;
	bool canslide;
	double aircontrol;
	double fricmod; // Inverse friction mod; 1.0 = no friction applied.
	
	// Input device(s)
	bool using_controller;
	bool block_moveinput;
	
	// Buffs
	double speedboost;
	
	// Jump delay
	int prevjump;
	int fricwait;
	int maxjumps;
	int jumpdodgecooldown;
	
	// Footsteps
	int stepTimer;
	
	// Presistent values
	double lastmovedir;
	int jumpcounter;
	
	// Dash
	bool enable_dash;
	double dashcooldown;
	double dashpower;
	int dashcooldown_time;
	int dashmax;
	int dashcounter;
	
	// Slide
	double slidecooldown;
	
	// Grapple
	bool gpl_validsurface;
	
	// Database(s)
	transient Dictionary surfacesData;
	
	// Velocities
	vector3 oldvel;
	vector3 viewAnglesVel;
	vector3 spaceAccel;
	
	// CVars
	transient CVar cv_snd_jump;
	transient CVar cv_vol_footstep;
		
	// Special movement
	LedgeTrigger ledgeGrabber;
	
	vector2 getMovementInputs(double rotation = 0)
	{
		let cmd = player.cmd;
		if( !(player.cmd.forwardmove || player.cmd.sidemove) )
			return (0,0);
	
		double moveNormRatio = gameinfo.normforwardmove[0] / gameinfo.normsidemove[0];
		vector2 norminput = (
			  cmd.forwardmove / (gameinfo.normforwardmove[0]*256.),
			-(cmd.sidemove / (gameinfo.normsidemove[0]*256.))
		);
		
		norminput.x = clamp(norminput.x, -1.0, 1.0);
		norminput.y = clamp(norminput.y, -1.0, 1.0);
		norminput.y *= moveNormRatio; // Mimic SR40 acceleration.
	
		return (rotation == 0) ? norminput : RotateVector(norminput, rotation);
	}
	
	void ThrustDir(double fw = 0, double lr = 0, double ud = 0)
	{
		let dir = Quat.FromAngles(angle, pitch, roll);
		vel += dir * (fw,lr,ud);
	}

	void DoSpaceLook()
	{
		// Get look inputs
		UserCmd cmd = player.cmd;
		double scalar = (360 / 65536.0);
		double cmdYaw = cmd.yaw * scalar;
		double cmdPitch = -cmd.pitch * scalar;
		double cmdRoll = cmd.roll * scalar;
		
		// Create quaternion based on look delta
		Quat input = Quat.FromAngles(cmdYaw, cmdPitch, cmdRoll);
		
		// Offset our current rotation quaternion with look delta.
		ViewRotation *= input;
		
		// Create quaternion based off our current facing direction
		// interpolate it to our new rotation based off our input delta.
		Quat r = Quat.FromAngles(angle, pitch, roll);
		r = Quat.SLerp(r, ViewRotation, 0.4);

		// Set angles to new look direction
		vector3 eulerAngles = HaloMath.GetEuler(r);
		A_SetAngle(eulerAngles.x, SPF_Interpolate);
		A_SetPitch(eulerAngles.y, SPF_Interpolate);
		A_SetRoll(eulerAngles.z, SPF_Interpolate);
		
	}
	void DoSpaceMovement(vector3 wishdir, double spd = 0.35)
	{
		if(gravity != 0) gravity = 0;
		
		// Wishdir doesn't work as desired in this case, so we'll need to convert
		// to relative coords.
		vector2 fwlr = getMovementInputs(); 
		
		vector3 reldir = (fwlr, wishdir.z);
		vector3 accelDir = ViewRotation * reldir;
		spaceAccel += accelDir * spd;
		
		if( !(vel ~== (0,0,0)) && !(accelDir ~== (0,0,0)) )
		{
			double dirDiff = (vel.Unit() dot accelDir.Unit());
			if(dirDiff < 0) A_StartSound("Halo/Powerup/Jetpack/Burst", CHAN_SPACEJETS, CHANF_NOSTOP, volume:0.5); 
		}
	}
	void DoSpaceFriction()
	{
		vel += spaceAccel;
	
		if( !(spaceAccel ~== (0,0,0)) && spaceAccel.Length() > 0 )
			A_StartSound("Halo/Powerup/Jetpack/Loop", CHAN_SPACEJETLOOP, CHANF_LOOPING, volume:0.5);
		else
			A_StopSound(CHAN_SPACEJETLOOP);
	
		spaceAccel *= 0.55;
		vel *= 0.96;
	}
	void SetSpaceMovement(bool onoff)
	{
		// Reset view rotation.
		ViewRotation = Quat.FromAngles(angle, pitch, roll);
		spacemovement = onoff;
				
		if(onoff) 
			Gravity = 0;
		else
			A_Gravity();
	}

	void DoDoomGroundAccel(double spd)
	{
		double fw = player.cmd.forwardmove;
		double lr = player.cmd.sidemove;
		
		if(speedboost) spd *= speedboost;
		if (fw || lr)
		{
			double forwardmove, sidemove;
			double friction, movefactor;

			[friction, movefactor] = GetFriction();
			if (!player.onground && !bNoGravity && !waterlevel)
			{
				// [RH] allow very limited movement if not on ground.
				movefactor *= level.aircontrol;
			}

			fw *= spd / 256;
			lr *= spd / 256;

			// When crouching, speed has to be reduced
			if (CanCrouch() && player.crouchfactor != 1)
			{
				fw *= player.crouchfactor;
				lr *= player.crouchfactor;
			}

			forwardmove = fw * movefactor * (35 / TICRATE);
			sidemove = lr * movefactor * (35 / TICRATE);
		
			if (forwardmove) 
			{
				vel.xy += (
					cos(Angle),
					sin(Angle)
				) * forwardmove;
			}
			if (sidemove)
			{
				let a = Angle - 90;
				vel.xy += (
					cos(a),
					sin(a)
				) * sidemove;
			}
		}
	}

	void DoQuakeGroundAccel(vector3 wishdir, double spd)
	{	
		if(doomermovement) 
		{
			DoDoomGroundAccel(DOOMGNDACCEL*spd);
			return;
		}
		
		if(speedboost) spd *= speedboost;
		double curspd = wishdir dot vel;
		double addspd = clamp(GNDMAX - curspd, 0, (GNDACCEL*spd) / TICRATE);
		
		vel += addspd * wishdir;
	}
	
	void DoQuakeAirAccel(vector3 wishdir, double spd, bool dobhop)
	{
		if(doJetpackMovement) 
		{
			vector2 moveDir = getMovementInputs();
			viewAnglesVel.y += moveDir.x * 0.1;
			viewAnglesVel.z += moveDir.y * 0.17;
		
			vel += wishdir * (spd * 1.1);
			return;
		}
	
		if(speedboost) spd *= speedboost;
		if(dobhop)
		{
			double curspd = wishdir dot vel;
			double addspd = clamp(AIRMAX - curspd, 0, (AIRACCEL*spd) / TICRATE);
					
			vel += (addspd*AIRCONTROL) * wishdir;
			if(AIRCONTROL < 1.) 
			{
				vector2 forward = (
					cos(angle),
					sin(angle)
				) * addspd;
				vel += forward * 0.1;
			}
		}
		else
		{
			double accel = (AIRACCEL*spd) / TICRATE;
			vector3 wishvel = vel + (wishdir * accel);
			double curspd = wishvel.Length();

			double addspd = clamp(AIRMAX - curspd, 0, accel);
			vel += (addspd*AIRCONTROL) * wishdir;
		}
	}
	
	bool CheckBuoyant()
	{
		return waterlevel >= 2 || player.cheats & CF_FLY || bFly;
	}
	
	String GetFloorSurface()
	{
		if(!surfacesData) 
			surfacesData = HaloDoom_Events.GetSurfacesData();
	
		if(!player.onground) return "None";
		
		string floorName = TexMan.GetName(floorpic);
		String surfaceType = surfacesData.At(floorName);
		
		// Attempt to automatically resolve terrain type.
		if(!surfaceType || !surfaceType.length()) 
		{
			surfaceType = "Halo/Surface/Normal"; 
			
			let terrain = GetFloorTerrain();
			String tName = terrain.TerrainName;
			if(terrain.isLiquid) 
				surfaceType = "Halo/Surface/Water";
			if(tName.IndexOf("grass") != -1) 
				surfaceType = "Halo/Surface/Nature";
		}
		
		return surfaceType;
	}
	
	void PlaySurfaceSound(string type)
	{
		double vol = 1.0;
		string surfaceType = GetFloorSurface();
		if(cv_vol_footstep) vol *= cv_vol_footstep.getFloat();
		
		A_StartSound(String.Format("%s/%s", surfaceType, type), CHAN_AUTO, volume:vol);
	}
	
	void ResetMovementMods()
	{	
		fricmod = 0; 
		aircontrol = default.aircontrol;
		gravity = default.gravity;
	}
	
	void PlayFootsteps()
	{	
		double curSpeed = vel.xy.Length();
		double vol = curSpeed / max(0.01, 15 * speed * forwardMove1);
		
		if(!cv_vol_footstep) cv_vol_footstep = CVar.GetCVar("halodoom_footstep_volume", player);
		if(cv_vol_footstep) vol *= cv_vol_footstep.getFloat();

		// Don't play if moving too slowly or sliding.
		if(curSpeed <= 1 || FindInventory("SlideAnimator")) 
		{
			stepTimer = 0;
			return;
		}
		
		String surfaceType = GetFloorSurface();
		if(--stepTimer <= 0)
		{
			A_StartSound(String.Format("%s/Footstep", surfaceType), CHAN_AUTO, volume:vol);
			stepTimer = max(4, 20 - curSpeed);
		}
	}
	
	override void MovePlayer ()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
		bool moving = (cmd.forwardmove || cmd.sidemove);
		bool predicting = (player.cheats & CF_PREDICTING);		
		doomermovement = halodoom_classicmovement;
		
		// Add a ledge grabber if we don't have one.
		if(!ledgeGrabber && !predicting) ledgeGrabber = LedgeTrigger.Init( self, 24,0,16 );
		
		// Play sound if landed from a fall.
		double zdiff = vel.z-oldvel.z;
		if(zdiff >= 10 && pos.z <= floorz) A_StartSound("Halo/Spartan/Land/Hard", CHAN_AUTO);
		
		// [RH] 180-degree turn overrides all other yaws
		if(!spacemovement)
		{
			if (player.turnticks)
			{
				player.turnticks--;
				Angle += (180. / TURN180_TICKS);
			}
			else
			{
				Angle += cmd.yaw * (360./65536.);
			}
		}
		else
		{
			DoSpaceLook();
		}

		if(curvehicle) return;
		
		// Process friction every couple of tics.
		double frictionScale = (1.0-fricmod);
		if(jumpdodgecooldown >= (DODGECOOLDOWN * 0.5) ) frictionScale *= 0.5;
		
		double fric = 6.0 * frictionScale;
		if( player.onground && (fricwait > 4 || !halodoom_allowbhop || !enable_bhop) && fric > 0) 
			DoQuakeFriction(fric);
			
		// Air friction
		if(!player.onground) DoAirFriction();
			
		player.onground = !spacemovement && (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);
		if(player.onground) 
			fricwait ++;
		else 
			fricwait = 0;
		
		DetectController();
		if (moving)
		{
			// Calculate wishdir
			UserCmd cmd = player.cmd;
			vector3 wishdir;
			wishdir.xy = getMovementInputs(angle);
			if(block_moveinput) wishdir.xy = (0,0);
			wishdir.z = 0;
			
		    lastmovedir = atan2(wishdir.y, wishdir.x);
			
			if( (cmd.forwardmove || cmd.sidemove) )
			{
				if(spacemovement)
				{
					DoSpaceMovement(wishdir);
				}
				else
				{
					if( (player.onground || bFly) && !doJetpackMovement ) 
						DoQuakeGroundAccel(wishdir, Speed);
					else
						DoQuakeAirAccel(wishdir, Speed, halodoom_allowbhop && enable_bhop);
				}
			}
			
			if (!(player.cheats & CF_PREDICTING)) PlayRunning ();
			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
		}
		
		uint btns = player.cmd.buttons;
		uint obtns = player.oldbuttons;
		
		// View angles
		A_SetViewAngle(viewangle + viewAnglesVel.x, SPF_INTERPOLATE);
		A_SetViewPitch(viewpitch + viewAnglesVel.y, SPF_INTERPOLATE);
		A_SetViewRoll (viewroll  - viewAnglesVel.z, SPF_INTERPOLATE);
		viewAnglesVel *= 0.92;
		viewroll  *= 0.87;
		viewangle *= 0.92; 
		viewpitch *= 0.92;
		
		player.vel = vel.xy;
		if(block_moveinput) player.vel *= 0;
		oldvel = vel;
		
		// Slide
		if(predicting) return; // Don't run movement abilities while predicting.
		if( (btns & BT_CROUCH) && !(obtns & BT_CROUCH) && vel.length() > 5 && player.onground && canslide && slidecooldown <= 0)
		{
			// If slide success and not predicting movement, play slide sound.
			let haloweap = HaloGun(player.ReadyWeapon);
			if( SlideAnimator.DoSlide(self, SLIDE_TICS) && (haloweap && !haloweap.feetbusy) )
			{
				slidecooldown = SLIDE_COOL;
				A_StartSound("Halo/Spartan/Slide", CHAN_BODY, CHANF_OVERLAP);
			}
		}
		
		// Dash
		if( (btns & BT_DASH) && !(obtns & BT_DASH) && dashcounter < dashmax )
		{
			DashAnimator.DoDash(self, lastmovedir, dashpower);
			A_StartSound("Halo/Spartan/Dash", CHAN_BODY, CHANF_OVERLAP);
			dashcounter++;
			dashcooldown = dashcooldown_time * 35.0;
		}
		
		if(slidecooldown) slidecooldown--;
		if(dashcooldown) dashcooldown--;
		if(jumpdodgecooldown) jumpdodgecooldown--;
	
		if(dashcooldown <= 0 && player.onground) dashcounter = 0;
		
		// Grappling hook
		let weap = HaloGun(player.ReadyWeapon);
		
		if( (btns & BT_GRAPPLE) && !(obtns & BT_GRAPPLE) && enable_grapple && (weap && !weap.handsbusy) )
		{
			if(grapple)
				grapple.Retract();
			else
				grapple = GrapplingHook.Deploy(self, (-10,-8,-10));
		}
		
		// Determine if grapple is deployable.
		if(enable_grapple && !grapple)
			gpl_validsurface = GrapplingHook.CanDeploy(self, (-5,-2,-2));
			
		PlayFootsteps();		
		JetpackMove();
	}		
	
	int jumpHeld;
	double jetThrustPerc;
	int jetQuake;
	const SND_JETLOOP = 20;
	const JETHOLD = 15;
	void JetpackMove()
	{
		let jetPower = PowerJetpack(FindInventory("PowerJetpack"));		
		if(bFly || !jetPower) // Do not jetpack while flying, or if we don't have the powerup.
		{
			jumpHeld = jetThrustPerc = doJetpackMovement = 0;
			return;
		}
			
		uint btns = player.cmd.buttons;
		uint obtns = player.oldbuttons;
		bool jumpdown = ((btns & BT_JUMP) && (obtns & BT_JUMP)) && (jetPower.fuel > 0) && !jetPower.coolingdown;
		
		if(jumpdown)
		{
			jumpHeld++;
			if(jumpHeld == int(JETHOLD*0.8))
				A_StartSound("Halo/Powerup/Jetpack/Burst", CHAN_AUTO, CHANF_OVERLAP);
		}
		else if(jumpHeld > 0)
		{
			A_StopSound(SND_JETLOOP);
			jetQuake = 0;
			jumpHeld--;
			if(jumpHeld >= 8) 
			{
				if(!spacemovement)
					vel.z += GetGravity() * 0.8;
				else
					ThrustDir(1);
			}
			if(player.onground) jumpHeld = 0;
		}
		
		if(jumpHeld >= JETHOLD && jumpdown)
		{
			jetPower.fuel -= 1.0 / (35*jetPower.thrustTime);
			if(jumpHeld == JETHOLD && !spacemovement) doJump();
				
			jetThrustPerc = HaloMath.Lerp(jetThrustPerc, 1.0, 0.08);
			if(jetThrustPerc > 0.65) jetThrustPerc = 1.0;
			
			if(jetThrustPerc >= 1.0) 
				A_StartSound("Halo/Powerup/Jetpack/Loop", SND_JETLOOP, CHANF_LOOPING);
			else
				A_StopSound(SND_JETLOOP);

			
			double jetBob = 0;
			if(jetThrustPerc >= 1.0)
				jetBob = sin(GetAge() * 10) * 1.75;
				
			doJetpackMovement = true;
			double thrust = jetThrustPerc * (GetGravity()*1.000000000000000000001);
			
			double maxZ = min(ceilingz-50, (floorz+200));
			if(!spacemovement)
			{
				if( (player.viewz + thrust) >= maxZ ) 
					vel.z = 0;
				else
					vel.z += thrust;
			}
			else
			{
				jetBob = 0; // Disable bobbing
				ThrustDir(jetThrustPerc * 2);
			}
			jumpHeld = JETHOLD * 2;
			
			// Math is odd to apply this on vel.z, so just change the position.
			SetOrigin((pos.xy, pos.z + jetBob), true);
			
			if(++jetQuake >= 8)
			{
				if(jetThrustPerc >= 1.0)
					A_QuakeEx(2,0,4,12, 0, 64, "", QF_RELATIVE | QF_WAVE | QF_SCALEUP, 0.7,0.7,0.7);
				else
					A_QuakeEx(2,2,2,12, 0, 64, "", QF_WAVE | QF_SCALEUP | QF_SCALEDOWN);
					
				jetQuake = 0;
			}
		}
		else
		{
			if(doJetpackMovement) A_StartSound("Halo/Powerup/Jetpack/Off", CHAN_AUTO, CHANF_OVERLAP);
			A_StopSound(SND_JETLOOP);
			if(player.onground) jetThrustPerc = 0;
			jetThrustPerc = HaloMath.Lerp(jetThrustPerc, 0, 0.04);
			doJetpackMovement = false;
		}
	}
	
	void DetectController()
	{
		UserCmd cmd = player.cmd;
		uint movebtns = (BT_FORWARD | BT_MOVELEFT | BT_MOVERIGHT | BT_BACK);
		
		bool moving_analog  = (cmd.forwardmove | cmd.sidemove);
		bool moving_digital = (cmd.buttons & movebtns);
		bool moving = moving_analog | moving_digital;
		
		if(moving) using_controller = !moving_digital;
	}
	
	override void CheckCrouch(bool totallyfrozen)
	{	
		let player = self.player;
		uint btns = player.cmd.buttons;
		uint obtns = player.oldbuttons;
		bool crouching = (btns & BT_CROUCH);
		
		if(spacemovement && crouching)
		{
			// Do thrusters
			DoSpaceMovement((0,0,-1));
			return;
		}
		
		if(CheckBuoyant() && crouching)
		{
			vel.z -= bFly ? 1 : 0.25;
			return;
		}
		
		super.CheckCrouch(totallyfrozen);
	}
	
	enum JUMPTYPE
	{
		JMP_FAILED = 0,
		JMP_NORMAL = 1,
		JMP_DOUBLE,
		JMP_DODGE
	};
	override void CheckJump()
	{
		let player = self.player;
		uint btns = player.cmd.buttons;
		uint obtns = player.oldbuttons;
		bool jumping = (btns & BT_JUMP);
				
		if(!cv_snd_jump) cv_snd_jump = CVar.GetCVar("halodoom_snd_jumpgrunt", player);
		
		if(spacemovement && jumping)
		{
			DoSpaceMovement((0,0,1));
			return;
		}
		
		if(CheckBuoyant() && jumping)
		{
			vel.z += 1;
			return;
		}
		
		bool doholdjump = enable_bhop && halodoom_allowbhop;
		if(player.onground) jumpcounter = 0;
		
		int jumpStatus = 0;
		vector2 moveinp = getMovementInputs();
		bool dodgingInput = abs(moveinp.x)+abs(moveinp.y) >= 0.3;
		
		if( player.onground && jumpdodging && dodgingInput && !jumpdodgecooldown )
		{
			// Do jump dodge
			double dodgevel = ((JumpZ*2.0) * 35) / TICRATE;
			vel += Quat.FromAngles(angle, pitch, roll) * (moveinp.x * dodgevel, moveinp.y * dodgevel, 0);	
		
			A_SetViewPitch(viewpitch + (moveinp.x * 5), SPF_INTERPOLATE);
			A_SetViewRoll(viewroll - (moveinp.y * 5), SPF_INTERPOLATE);
			
			jumpdodgecooldown = enable_bhop ? DODGECOOLDOWN*2.0 : DODGECOOLDOWN;
			jumpStatus = JMP_DODGE;
			doJump(0.35);
		}
		else if( !player.onground && jumpHeld <= 2 && jumping && !(obtns & BT_JUMP) && jumpcounter < maxjumps )
		{
			// Double jump
			jumpHeld = 0;
			vel.z = 0;	
			jumpStatus = doJump();
			if(jumpStatus != JMP_FAILED)
			{
				jumpStatus = JMP_DOUBLE;
				jumpcounter++;
			}
		} 
		else if ( player.onground && jumping && (!(obtns & BT_JUMP) || doholdjump) )
		{
			// Normal jump
			jumpHeld = 0;
			jumpStatus = doJump();
			if(jumpStatus != JMP_FAILED) jumpcounter++;
		}
		
		// Jump SFX
		if ( !(player.cheats & CF_PREDICTING) && cv_snd_jump.getBool() ) 
		{
			switch(jumpStatus)
			{
				case JMP_NORMAL:
					A_StartSound("*jump", CHAN_BODY, CHANF_OVERLAP);
				break;
				case JMP_DOUBLE:
					A_StartSound("Halo/Spartan/DoubleJump", CHAN_BODY, CHANF_OVERLAP);
				break;
				case JMP_DODGE:
					A_StartSound("Halo/Spartan/DodgeJump", CHAN_BODY, CHANF_OVERLAP);
				break;
			}
		}
	}
	
	int doJump(double forcemod = 1.0)
	{
		if (player.crouchoffset != 0) player.crouching = 1;
		if (waterlevel >= 2) Vel.Z = 4 * Speed;
		if (bNoGravity) Vel.Z = 3.;
			
		if(!level.IsJumpingAllowed()) return JMP_FAILED;
		
		if(abs(level.time - prevjump) <= 4) return false;
		prevjump = level.time;
		
		double jumpvelz = JumpZ * 35 / TICRATE;
		double jumpfac = 0;
		prevjump = level.time;

		for (let p = Inv; p != null; p = p.Inv)
		{
			let pp = PowerHighJump(p);
			if (pp) jumpfac = pp.Strength > jumpfac ? pp.Strength : jumpfac;
		}
		if (jumpfac > 0) jumpvelz *= jumpfac;
		
		bool canJumpHere = (pos.z+height < ceilingz);
	
		if(canJumpHere)
		{
			if(level.IsJumpingAllowed())
			{
				Vel.Z += jumpvelz * forcemod;
				bOnMobj = false;
				player.jumpTics = -1;
			
				// Play jump sound(s)
				PlaySurfaceSound("Jumped");
			}
		}
		return !canJumpHere ? JMP_FAILED : JMP_NORMAL;
	}
	
	// Credits: Ivory Duke (ZMovement)
	double GetFloorAngle()
	{
		// Get Floor Normal
		Vector3 floornorm;
		F3DFloor floors;
		for(int i = 0; i < FloorSector.Get3DFloorCount(); i++)
		{
			if(FloorSector.Get3DFloor(i).Top.ZAtPoint(Pos.XY) ~== FloorZ)
			{
				floors = FloorSector.Get3DFloor(i);
				break;
			}
		}
		floornorm = floors ? -floors.Top.Normal : FloorSector.FloorPlane.Normal;
		return atan2(floornorm.XY.Length(), floornorm.Z);
	}
	
	void DoDoomFriction()
	{
		if(player.onground) 
			vel.xy *= DOOMGNDFRIC;
	}
	
	void DoAirFriction()
	{
		if(doJetpackMovement) vel.xy *= 0.92;
		if(spacemovement) DoSpaceFriction();
	}
	
	void DoQuakeFriction(double friction)
	{
		if(doomermovement)
		{
			DoDoomFriction();
			return;
		}
		
		double maxspd = GNDMAX;
		double unitfric = friction / TICRATE;
		double floorangle = GetFloorAngle();
		double swimming = WaterLevel >= 2 || bNOGRAVITY;
		double minvel = (swimming) ? 0.5 : 1.0;

		// Stop velocity of too small.
		if(vel.length() < minvel)
		{
			vel.xy = (0, 0);
			return;
		}
		// Lower friction if on a slope.
		if(floorangle >= 45 && player.onground) 
		{
			maxspd *= 4;
			friction /= 4;
		}
		
		// Apply friction
		double curspeed = vel.Length();
		if( !(curspeed ~== 0) )
		{
			double control = (swimming ? curspeed : (curspeed < maxspd ? GNDFRIC : curspeed));
			double drop = control * unitfric;
			double newspeed = curspeed - drop;
			double frictionmod = (newspeed <= 0 ? 0 : newspeed) / curspeed;
		
			vel.xy *= frictionmod;
			if(swimming) vel.z *= frictionmod;
		}
	}
}

class DashAnimator : Inventory
{
	double dashdir;
	double dashstr;
	double timeout;
	
	Default
	{
		+INVENTORY.UNDROPPABLE;
		inventory.maxamount 1;
	}
	
	static DashAnimator DoDash(Actor src, double dir, double spd, double dur = 5)
	{
		let prevDash = DashAnimator(src.FindInventory("DashAnimator"));
		if(prevDash)
		{
			prevDash.dashdir = dir;
			prevDash.dashstr = spd*1.5;
			prevDash.timeout = dur;
			return prevDash;
		}
		
		let dash = DashAnimator(Actor.Spawn("DashAnimator"));
		if(dash)
		{
			dash.dashdir = dir;
			dash.dashstr = spd;
			dash.timeout = dur;
			src.AddInventory(dash);
			src.vel *= 0;
		}
		return dash;
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		let plr = HaloPlayer(Owner);
		if(!plr) return;
		
		if(GetAge() > timeout) 
		{
			plr.bNOGRAVITY = Owner.default.bNOGRAVITY;
			if(GetAge() > timeout*2.0)
			{
				plr.RemoveInventory(self);
				plr.fricmod = 0;
				plr.enable_bhop = plr.default.enable_bhop;
				GoAwayAndDie();
			}
		}
		else
		{
			vector2 addvel = AngleToVector(dashdir, dashstr);
			plr.vel.xy += addvel;
			plr.fricmod = 1.0;
			plr.enable_bhop = true;
			plr.bNOGRAVITY = true;		
		}
	}
}

class SlideAnimator : Inventory
{
	double timeout;
	double animtimer;
	double def_fov; 
	
	Default
	{
		+INVENTORY.UNDROPPABLE;
		inventory.maxamount 1;
	}
	
	static SlideAnimator DoSlide(Actor src, double dur = 35)
	{
		if(src.FindInventory("SlideAnimator") || !src.player) return null;
		let slide = SlideAnimator(Actor.Spawn("SlideAnimator"));
		if(slide)
		{
			slide.timeout = dur;
			src.AddInventory(slide);
			src.vel.xy *= 3.0;
			src.A_SetSize(src.default.radius, src.default.height * 0.5);
		}
		return slide;
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		let plr = HaloPlayer(Owner);
		if(!plr) return;
		
		if(!def_fov) def_fov = plr.player.DesiredFOV;
		
		vector2 addvel = AngleToVector(atan2(plr.vel.y, plr.vel.x), 1.5);
		
		if(plr.player.onground) 
			plr.vel.xy += addvel;
		else
			timeout = 0;
			
		plr.fricmod = 1.0;
		plr.block_moveinput = true;
		
		if(animtimer < 10)
		{
			plr.viewoffs -= 2.5;
			plr.A_SetPitch(plr.pitch - 0.45, SPF_INTERPOLATE);
			plr.player.DesiredFOV = HaloMath.Lerp(plr.player.DesiredFOV, def_fov*1.15, 0.10);
		} 
		else if(animtimer > timeout-10)
		{
			plr.A_SetPitch(plr.pitch + 0.45, SPF_INTERPOLATE);
			plr.viewoffs = HaloMath.Lerp(plr.viewoffs, 0, 0.1);
			plr.player.DesiredFOV = HaloMath.Lerp(plr.player.DesiredFOV, def_fov, 0.10);
		}
		animtimer++;
		
		if(GetAge() > timeout) 
		{
			plr.RemoveInventory(self);
			plr.fricmod = 0;
			plr.viewoffs = 0;
			plr.block_moveinput = false;
			plr.player.DesiredFOV = def_fov;
			plr.A_SetSize(plr.default.radius, plr.default.height);
			GoAwayAndDie();
		}
	}
}

// Ledge grabbing
class LedgeTrigger : CheapActor
{
	Actor plr;
	vector3 offs;
	vector3 grabPos;
	uint grabTics;
	uint grabDelay;
	uint grabCooldown;
	
	static LedgeTrigger Init(Actor src, double fw, double lr, double ud)
	{
		let grab = LedgeTrigger(Spawn("LedgeTrigger", src.pos));
		if(grab)
		{
			grab.plr = src;
			grab.offs = (fw, lr, ud);
		}
		return grab;
	}
	
	override void Tick()
	{
		super.Tick();
		if(!plr || !plr.player) return;

		while(grabTics > 0)
		{
			plr.vel *= 0; // Stop moving.
			plr.player.cheats |= CF_FROZEN;
			
			if(plr.player.cmd.buttons & BT_CROUCH)
			{
				// Cancel grab.
				grabTics = 0;
			}
			
			if(grabDelay) 
			{
				// Wait for grab animation.
				grabDelay--;
			}
			if(grabDelay <= 0)
			{
				grabTics--;
				vector3 toPos = HaloMath.Lerp3D(plr.pos, grabPos, 0.1);
				plr.SetOrigin(toPos, true);
				
				// Set position to grab pos.
				if(grabTics <= 0) plr.SetOrigin(grabPos, true);
			}
			
			if(grabTics <= 0)
			{	
				// Finish grab
				plr.player.cheats &= ~CF_FROZEN;
			}
			return;
		}
		if(grabCooldown) grabCooldown--;
			
		double lookHeight = plr.player.viewz-plr.pos.z;
		vector3 fromPos = (plr.pos.xy, plr.player.viewz);
		
		// Update pos
		vector3 followPos = HaloMath.V3Offset(plr.angle, 0, plr.roll, offs.x,offs.y,offs.z, 1.0);
		SetOrigin(level.vec3offset(fromPos, followPos), true);
		
		bool falling = !plr.player.onground && plr.vel.z < 0;		
		bool hitFloor = pos.z <= floorz;
	
		// Check for physical floor.
		FLineTraceData lt;
		LineTrace(angle, 16, 90, flags:TRF_THRUACTORS, data:lt);
		if(lt.HitType == TRACE_HitFloor) hitFloor = true;
		
		if(falling && hitFloor && grabCooldown <= 0)
		{
			// Perform visibility check to make sure we don't grab things through the floor.
			bool visiblePos = plr.IsVisible(self, true);
			vector3 prevPos = plr.pos;
			
			// Set player Z to destination Z so that CheckPosition is 3D aware.
			plr.SetXYZ((pos.xy, pos.z));
			bool validPos = visiblePos && plr.CheckPosition(pos.xy);
			// Reset player position.
			plr.SetXYZ(prevPos);
			 
			if( validPos )
			{
				// We have a clear path towards the ledge.
				// Setup grabbing sequence.
				grabPos = (pos.xy, pos.z);
				grabTics = 20;
				grabDelay = 8;
				grabCooldown = grabTics + grabDelay + 20;
			}
		}
	}	

	States
	{
		Spawn:
			TNT1 A -1; // PLSS for Debug
		stop;
	}
}
