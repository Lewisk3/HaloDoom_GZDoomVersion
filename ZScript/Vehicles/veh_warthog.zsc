class Warthog_Tire : VehPart
{
	bool invert;
	double trueturn;
	double turnvel;
	Property BackTires : invert;
	
	Default
	{
		Radius 16;
		Height 16;
		Scale 1.0;
	}
	
	double GetSteerAngle(bool behind = false)
	{
		double fromangle = behind ? base.driver.angle-180 : base.driver.angle;
		return -HaloMath.AngleDiff(fromangle, base.angle);
	}
	
	override void UpdatePos(bool moving)
	{
		if(!base) return;
		vector3 finalpos = GetOffsetPos(base);
		SetOrigin(finalpos, moving);
		
		if(base.vehflags & base.bALIGNTOPLANE)
			HaloMath.AlignToPlane(self, ignorepitch:true);
			
		if(!base.driver) return;
		
		let warthog = HaloWarthog(base);
		
		// Determine angle based on aim.
		// Get angle of "steering wheel"
		double steerangle = GetSteerAngle();
		bool behind = steerangle < -(180 - 50) || steerangle > (180 - 50);
		if(behind) steerangle = GetSteerAngle(true);
		if(invert) steerangle = -steerangle;
		
		trueturn = base.angle + clamp(steerangle, -50, 50);
		steerangle = clamp(steerangle, -30, 30);
		
		A_SetAngle(steerangle + base.angle, SPF_INTERPOLATE);
		A_SetPitch(pitch + warthog.accel, SPF_INTERPOLATE);
	}
		
	States
	{
		Spawn:
			MODL A 1;
		loop;
	}
}
class Warthog_BackTire : Warthog_Tire 
{
	Default
	{
		WartHog_Tire.BackTires true;
	}
}

// Turret
class Warthog_TurretBase : VehPart
{
	Warthog_TurretGun gun;
	uint cooldown_primary;
	double spinspeed;
	double turretspin;
	
	Default
	{
		Radius 28;
		Height 32;
		+SOLID;
	}
	
	override void OnAttach()
	{
		gun = Warthog_TurretGun(VehPart.Attach("Warthog_TurretGun", base, (32,0,38), (0,0))); 
		if(gun) gun.gunbody = self;
	}
	
	override void OnDestroy()
	{
		gun.Destroy();
	}
	
	override void UpdatePos(bool moving)
	{
		super.UpdatePos(moving);
		
		let warthog = HaloWarthog(base);
		if(!warthog) return;
		
		vector2 gunnerangles = (
			warthog.gunner ? warthog.gunner.angle : base.angle,
			warthog.gunner ? warthog.gunner.pitch : base.pitch
		);
		A_SetAngle(gunnerangles.x, SPF_INTERPOLATE);
		A_SetPitch(base.pitch, SPF_INTERPOLATE);
		
		gun.A_SetPitch(gunnerangles.y, SPF_INTERPOLATE);
	}
	
	override void DoUpdate(VehCamera cam)
	{
		let warthog = HaloWarthog(base);
		if(!warthog || !warthog.gunner) return;
		let gcam = VehCamera(warthog.gunner.player.camera);
		if(!gcam) return;
		
		if(cooldown_primary) 
		{
			gcam.SetZoom(1.0, 0.1);
			cooldown_primary--;
		}
		
		bool shooting = CheckButtons(BT_ATTACK, VehButtons.BTS_DOWN, warthog.gunner);
		
		if( shooting && !cooldown_primary )
		{
			cooldown_primary = 10 - (7 * spinspeed);
			double rmax = 1.5;
			double arecoil = frandom(-rmax, rmax);
			double precoil = frandom(-rmax, rmax);
			HaloMath.FireProjectile("HaloMagnum_Bullet", gun.pos, gun.angle + arecoil, gun.pitch + precoil, 0, 40, 0, 1, 200);
			A_StartSound("Halo/Weapons/Rifle/Fire", CHAN_BODY, CHANF_OVERLAP);
			gcam.Quake(1.25,1.25,0,0.5);
			spinspeed += 0.1;
			turretspin += 45;
		}
		else if(!shooting)
		{
			spinspeed *= 0.95;
		}
		spinspeed = clamp(spinspeed, 0, 1.0);
	}
			
	States
	{
		Spawn:
			MODL A 1;
		loop;
	}
}

class Warthog_TurretGun : VehPart
{
	VehPart gunbody;
	Warthog_TurretBarrel gunbarrel;
	
	Default
	{
		Radius 16;
		Height 16;
	}
	
	override void OnAttach()
	{
		gunbarrel = Warthog_TurretBarrel(VehPart.Attach("Warthog_TurretBarrel", base, (15,0,0), (0,0))); 
		if(gunbarrel) gunbarrel.gun = self;
	}
	
	override void OnDestroy()
	{
		gunbarrel.Destroy();
	}
	
	override void UpdatePos(bool moving)
	{
		if(!gunbody) return;
		vector3 finalpos = GetOffsetPos(gunbody);
		SetOrigin(finalpos, moving);
		
		if(base.vehflags & base.bALIGNTOPLANE)
			HaloMath.AlignToPlane(self);
		
		A_SetAngle(gunbody.angle, SPF_INTERPOLATE);	
	}
	
	States
	{
		Spawn:
			MODL A 1;
		loop;
	}
}

class Warthog_TurretBarrel : VehPart
{
	VehPart gun;
	Default
	{
		Radius 16;
		Height 16;
	}
	
	override void UpdatePos(bool moving)
	{
		let warthog = HaloWarthog(base);
		if(!gun || !warthog) return;
		
		vector3 finalpos = GetOffsetPos(gun);
		SetOrigin(finalpos, moving);
		
		double proll = roll;
		if(base.vehflags & base.bALIGNTOPLANE)
			HaloMath.AlignToPlane(self);
		
		roll = HaloMath.Lerp(roll, warthog.turret.turretspin, 0.15);
		A_SetAngle(gun.angle, SPF_INTERPOLATE);
		A_SetPitch(gun.pitch, SPF_INTERPOLATE);
	}
	
	States
	{
		Spawn:
			MODL A 1;
		loop;
	}
}

class HaloWarthog : HaloVehicle
{
	Warthog_Tire Tire_TL, Tire_TR, Tire_BL, Tire_BR;
	Warthog_TurretBase turret;
	double throttle;
	double accelangle;
	double accel;
	vector2 relvel;
	
	// Passenger(s)
	PlayerPawn gunner;
	PlayerPawn passenger;
	
	Default
	{
		Radius 65;
		Height 55;
		Scale 45.0;
		
		Mass 800;
		Health 1000;
		HaloVehicle.Armored 500;
		MaxSlopeSteepness 0.2;
	}
	
	override void BeginPlay()
	{
		Tire_TL = Warthog_Tire(VehPart.Attach("Warthog_Tire", self, (65,-35,16), (0,0)));
		Tire_TR = Warthog_Tire(VehPart.Attach("Warthog_Tire", self, (65, 35,16), (0,0)));
		Tire_BL = Warthog_Tire(VehPart.Attach("Warthog_BackTire", self, (-65,-35,16), (0,0)));
		Tire_BR = Warthog_Tire(VehPart.Attach("Warthog_BackTire", self, (-65, 35,16), (0,0)));
		turret = Warthog_TurretBase(VehPart.Attach("Warthog_TurretBase", self, (-47, 0, 35), (0,0)));
		super.BeginPlay();
	}
	
	override void OnDestroy()
	{
		turret.Destroy();
	}
	
	override bool OnDriveAttempt(PlayerPawn user)
	{
		double gundist = user.Distance2D(turret);
		if(user == driver) return true;
		
		
		// Take gunner.
		if(!gunner && gundist <= 70) 
		{
			// Ready gunner seat.
			let cam = SetupHaloCamera(dist:-140,70, 30,50, 30,100, setcam:false);
			cam.source = user;
			AssignCamera(cam, user);
			ReadyDriver(user);
			
			gunner = user;
			return false;
		}
		else if(gunner && gunner == user)
		{
			RemoveDriver(gunner, GetExitPos());
			gunner = null;
			return false;
		}
		
		// Do take driver.
		return true;
	}
	
	override void TakeDriver(PlayerPawn user)
	{
		if(health <= 0) return;
		driver = user;
		
		SetupHaloCamera(dist:-140,60, 30,50, 30, 100);
		ReadyDriver(user);
	}
	
	override vector3 GetDrivePos()
	{	
		// Driver seat pos
		return (8,-20,10);
	}
	
	override void UpdatePassengers()
	{
		if(gunner) UpdateActorPos(gunner, (-60,0,35));
	}
	
	vector2 GetTireDir(Warthog_Tire tire)
	{
		return (cos(tire.trueturn), sin(tire.trueturn));
	}
	
	override void DoMove(float forwardmove, float sidemove)
	{	
		vel.xy *= 0.93;
		accel *= 0.96;
		
		if(health <= 0)  
		{
			if(driver) RemoveDriver(driver, GetExitPos());
			if(gunner) RemoveDriver(gunner, GetExitPos());
			return;
		}
		if(!driver) return;
		double tireforce = 0.80 * throttle;
		double tireangv = 0.15;
		
		// Add tire forces for velocities
		double adiff = 0;
		if(throttle > 0)
		{
			vel.xy += GetTireDir(Tire_TL) * tireforce;
			vel.xy += GetTireDir(Tire_TR) * tireforce;
			adiff = HaloMath.AngleDiff(angle, Tire_TL.angle) * tireangv * abs(tireforce);
		}
		else
		{
			vel.xy += GetTireDir(Tire_BL) * tireforce;
			vel.xy += GetTireDir(Tire_BR) * tireforce;
			adiff = HaloMath.AngleDiff(angle, Tire_BL.angle) * tireangv * abs(tireforce);
		}
		A_SetAngle(angle + adiff, SPF_INTERPOLATE);
		if(gunner) gunner.A_SetAngle(gunner.angle + adiff, SPF_INTERPOLATE);
		
		if(forwardmove)
		{
			vector2 movedir = (forwardmove, -sidemove).Unit();
			throttle += movedir.x * 0.03;
			accel += throttle * 1.5;
		}
		else
		{
			throttle *= 0.5;
		}		
		throttle = clamp(throttle, -0.5, 1.0);
		accel = clamp(accel, -10, 10);
		
		// Turning speed penalty
		vector2 dir = AngleToVector(angle);
		vector2 aimdir = AngleToVector(viewcam.angle);
		double cosAng = (dir dot aimdir); // -1 to 1;
		vector2 slowforce = AngleToVector(angle, tireforce) * (1.0-cosAng);
		vel.xy -= slowforce;
		
		DoCollisionDamage();
	}
	
	States
	{
		Spawn:
			MODL A 1;
		loop;
		
		Death:
			MODL A -1;
		stop;
	}
}