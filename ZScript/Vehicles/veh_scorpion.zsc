class Scorpion_TurretBase : VehPart
{
	Scorpion_TurretCannon cannon;
	Default
	{
		Radius 16;
		Height 16;
	}
	
	override void OnAttach()
	{
		cannon = Scorpion_TurretCannon( VehPart.Attach("Scorpion_TurretCannon", base,(50,0,40)) );
		cannon.turretbase = self;
	}
	
	override void UpdatePos(bool moving)
	{
		super.UpdatePos(moving);
		if(!base || !base.driver) return;
		
		A_SetAngle(base.driver.angle, SPF_INTERPOLATE);
		A_SetRoll(base.roll, SPF_INTERPOLATE);
		A_SetPitch(base.pitch, SPF_INTERPOLATE);
	}
	
	States
	{
		Spawn:
			MODL A 1;
		loop;
	}
}

class Scorpion_TurretCannon : VehPart
{
	uint cooldown;
	uint cooldown_chaingun;
	VehPart turretbase;
	Default
	{
		Radius 16;
		Height 16;
	}
	
	override void UpdatePos(bool moving)
	{
		if(!turretbase) return;
		vector3 finalpos = GetOffsetPos(turretbase);
		SetOrigin(finalpos, moving);
		
		A_SetAngle(turretbase.angle, SPF_INTERPOLATE);
		A_SetRoll(turretbase.roll, SPF_INTERPOLATE);
		
		double aimpitch = base.driver ? base.driver.pitch : 0;
		aimpitch = clamp(aimpitch, -30, 10);
		A_SetPitch(base.pitch + aimpitch, SPF_INTERPOLATE);
		
	}
		
	override void DoUpdate(VehCamera cam)
	{
		let tank = HaloScorpion(base);
		if(!tank) return;
		if(!cam) return;
	
		if(cooldown_chaingun) cooldown_chaingun--;
		if(cooldown) 
		{
			cam.SetZoom(1.0, 0.1);
			cooldown--;
		}
		if(CheckButtons(BT_ATTACK, VehButtons.BTS_PRESSED) && !cooldown)
		{
			TankRocket.Fire(self, (350, 0, 30));
			A_StartSound("Halo/Scorpion/Fire", CHAN_WEAPON, CHANF_OVERLAP);
			
			double kickback = -0.1 * abs(cos(base.angle-angle));
			tank.AdjustTreads(kickback);
			cam.SetZoom(0.93, 0.5);
			cam.Quake(20,20,0,0.6);
			
			cooldown = 70;
		}
		if(CheckButtons(BT_ALTATTACK, VehButtons.BTS_DOWN) && !cooldown_chaingun)
		{
			double rmax = 1.5;
			double arecoil = frandom(-rmax, rmax);
			double precoil = frandom(-rmax, rmax);
			let proj = HaloMath.FireProjectile("HaloMagnum_Bullet", pos, angle + arecoil, pitch + precoil, 40, 250, 40, 1, 200);
			
			// We need to set the target of this projectile if we want hitmarkers to show up
			// for the person who shoots it.
			proj.target = base.driver;
			
			A_StartSound("Halo/Weapons/Rifle/Fire", CHAN_WEAPON, CHANF_OVERLAP);
			cooldown_chaingun = 2;
		}
	}
	
	States
	{
		Spawn:
			MODL A 1;
		loop;
	}
}

class Scorpion_Tread : VehPart
{
	double traction;
	double rotation;
	Property Traction : traction;
	
	Default
	{
		Radius 50;
		Height 35;
		+SOLID;
		
		Scorpion_Tread.Traction 0.8;
	}
	
	override void Tick()
	{
		super.Tick();
	}
	
	override void UpdatePos(bool moving)
	{
		super.UpdatePos(moving);
		if(!base) return;
		
		let tank = HaloScorpion(base);
		if(!tank) return;
		
		rotation *= tank.friction;
		rotation = clamp(rotation, -1.0, 1.0);
		
		double topitch = HaloMath.fmap(rotation, -1.0, 1.0, 0.5, 2.0); 
		A_SoundPitch(CHAN_7, topitch);
		
		if(rotation > 0.001) 
			A_StartSound("Halo/Scorpion/Treads", CHAN_7, CHANF_LOOPING);
		else
			A_StopSound(CHAN_7);
		
		// Apply angular velocity based on rotation.
		int dir = HaloMath.sign(posoffs.y);
		double spdmod = HaloMath.fmap(base.vel.xy.Length(), 0, 15, 1.0, 2.0); 
		double turnvel = (traction * rotation) * 0.5;
		tank.angvel += turnvel * dir * spdmod;
		base.vel.xy += AngleToVector(base.angle, turnvel * 16);
				
		A_SetAngle(base.angle, SPF_INTERPOLATE);
		A_SetRoll(base.roll, SPF_INTERPOLATE);
	}
		
	States
	{
		Spawn:
			MODL A 1;
		loop;
	}
}

class ScorpionCamera : HaloVehCamera
{
	override void UpdatePos(bool moving)
	{
		if(!base) return;
		if(!source) return;
		if(!followact) followact = base;
		
		double a = source.angle;
		double p = base.driver.pitch;
		vector3 followpos = (
			cos(a) * cos(p),
			sin(a) * cos(p),
			-sin(p)
		) * dist_xy;
		followpos.z += dist_z;
		followpos.z = clamp(followpos.z, zmin, zmax);
		
		vector3 topos = level.vec3offset(followact.pos, followpos + relposoffs);
		vector3 curpos = HaloMath.Lerp3D(pos, topos, 0.65);
		curpos.z += base.GetBobOffset();
		
		A_SetAngle(a, SPF_INTERPOLATE);
		A_SetPitch(p, SPF_INTERPOLATE);
		SetOrigin(curpos, true);
	}
}

class Scorpion_TreadFR : Scorpion_Tread {}
class Scorpion_TreadFL : Scorpion_Tread {}
class Scorpion_TreadBL : Scorpion_Tread {}
class Scorpion_TreadBR : Scorpion_Tread {}

class HaloScorpion : HaloVehicle
{
	Scorpion_Tread TreadFL, TreadFR, TreadBL, TreadBR;
	Scorpion_TurretBase turret;
	double angvel;
	double friction;
	double throttle;
	
	Property TreadFriction : friction;

	Default
	{
		Radius 200;
		Height 100;
	
		Mass 800;
		Health 3000;
		HaloVehicle.Armored 4000;
		HaloScorpion.TreadFriction 0.80;
		MaxSlopeSteepness 0.4;
	}
	
	override void BeginPlay()
	{
		super.BeginPlay();
		
		TreadFL = Scorpion_Tread(VehPart.Attach("Scorpion_TreadFL", self, ( 140,-120,0)));
		TreadFR = Scorpion_Tread(VehPart.Attach("Scorpion_TreadFR", self, ( 140, 120,0)));
		TreadBL = Scorpion_Tread(VehPart.Attach("Scorpion_TreadBL", self, (-140,-140,0)));
		TreadBR = Scorpion_Tread(VehPart.Attach("Scorpion_TreadBR", self, (-140, 140,0)));
		turret = Scorpion_TurretBase(VehPart.Attach("Scorpion_TurretBase", self, (-110,0,100)));
	}
	

	override bool RemoveDriver(PlayerPawn user, vector3 exitpos)
	{	
		bool success = super.RemoveDriver(user, exitpos);
		if(user == driver && success) 
		{
			A_StartSound("Halo/Scorpion/EngineOFF", flags:CHANF_OVERLAP);
			A_StopSound(CHAN_7); // Engine Loop
		}
		return success;
	}

	override void TakeDriver(PlayerPawn user)
	{
		if(health <= 0) return;
		if(user) driver = user;
		let cam = SetupHaloCamera("ScorpionCamera", dist:-400,200,180,300);
		ReadyDriver(user);
		SetCrosshair(user, "ScorpRet", (1.0,1.0));
		A_StartSound("Halo/Scorpion/EngineON", flags:CHANF_OVERLAP);
		A_StartSound("Halo/Scorpion/EngineLoop", CHAN_7, CHANF_LOOPING);
	}
	
	override vector3 GetDrivePos()
	{
		return (-20,-5,0);
	}
	
	override vector3 GetExitPos(PlayerPawn user)
	{
		if(user == driver) return (-300, 0, 30);
		return (-20,-5,0);
	}
	
	void AdjustTreads(double amt)
	{
		TreadFL.rotation += amt;
		TreadFR.rotation += amt;
		TreadBL.rotation += amt;
		TreadBR.rotation += amt;
	}
	
	override void DoMove(float forwardmove, float sidemove)
	{	
		// Friction
		vel.xy *= 0.80;
		angvel *= 0.80;

		if(health <= 0)  
		{
			if(driver) RemoveDriver(driver, GetExitPos(driver));
			return;
		}
		if(!driver) return;
		
		double movespd = 0.03;
		double turnspd = 0.05;
		if(forwardmove || sidemove)
		{
			vector2 movedir = (forwardmove, sidemove).Unit();
			movedir.x *= movespd;
			movedir.y *= turnspd;
			movedir.y *= HaloMath.sign(movedir.x);
			
			TreadFL.rotation += movedir.x;
			TreadFR.rotation += movedir.x;
			TreadBL.rotation += movedir.x;
			TreadBR.rotation += movedir.x;
			
			TreadFL.rotation += movedir.y;	
			TreadFR.rotation -= movedir.y;	
			TreadBL.rotation += movedir.y;	
			TreadBR.rotation -= movedir.y;	
		}
		
		A_SetAngle(angle + angvel, SPF_INTERPOLATE);
		DoCollisionDamage();
	}
	
	States
	{
		Spawn:
			MODL A 1;
		loop;
		
		Death:
			MODL A -1;
		stop;
	}
}