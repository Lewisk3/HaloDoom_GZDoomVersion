/*
Copyright 2020 Lewisk3

Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the "Software"), to deal 
in the Software without restriction, including without limitation the rights 
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom the Software is 
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE.

~ MIT License ~
*/

class WeaponPickupProxy : Actor
{
	class<Weapon> trueitem;
	string truepickupmsg;
	sound truepickupsnd;
	HaloPlayer haloplr;
	PlayerPawn plr; // Valid player, but player isn't HaloPlayer.
	bool noammogive;
	bool forcepickup;
	int clipammo;
	int use_hold; // How many tics the USE key has been down for.
	
	double visibledist;
	Property PickupRange : visibledist;
	
	Default
	{
		Radius PICKUP_RANGE*0.25;
		Height PICKUP_RANGE*0.25;
		// +SOLID;
		WeaponPickupProxy.PickupRange PICKUP_RANGE*2.;
	}
	
	static bool ProcessDroppedWeapon(Weapon weap)
	{
		// Remove weapon 50% of the time.
		if(random[WorldDroppedWeapon](0,100) < 50)
		{
			weap.Destroy();
			return true;
		}
		return false;
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if(other is "PlayerPawn") return false;
		return super.CanCollideWith(other, passive);
	}
	
	static WeaponPickupProxy BecomeWeaponProxy(Weapon source, bool noammogive = false)
	{
		let wp = WeaponPickupProxy(Actor.Spawn("WeaponPickupProxy", source.pos));
		if(wp)
		{
			wp.truepickupmsg = source.PickupMessage();
			wp.truepickupsnd = source.pickupsound;
			wp.Sprite = source.Sprite;
			wp.Frame = source.Frame;
			wp.noammogive = noammogive;
			wp.trueitem = source.GetClass();
			wp.clipammo = -1;
			wp.A_SetSize(source.radius, source.height);
			source.Destroy();
		}
		return wp;
	}
	
	Weapon GiveWeaponItem(Actor to)
	{
		if(!to) return null;
		let ammotype1 = GetDefaultByType(trueitem).ammotype1;
		let ammotype2 = GetDefaultByType(trueitem).ammotype2;
		int ammogive1 = GetDefaultByType(trueitem).ammogive1;
		int ammogive2 = GetDefaultByType(trueitem).ammogive2;
		let ammodef1  = ammogive1 ? GetDefaultByType(ammotype1) : NULL;
		let ammodef2  = ammogive2 ? GetDefaultByType(ammotype2) : NULL;
		bool hasitem = to.countinv(trueitem);
		
		// Do not pickup if we already own this item but we have max ammo
		// for it.
		if(hasitem)
		{
			double togive;
			if(!to.countinv("backpack"))
			{
				if(ammodef1) togive += ammodef1.maxamount-to.countinv(ammotype1);
				if(ammodef2) togive += ammodef2.maxamount-to.countinv(ammotype2);
			}
			else
			{
				if(ammodef1) 
				{
					double ammomax = max(ammodef1.backpackmaxamount, ammodef1.maxamount);
					togive += ammomax-to.countinv(ammotype1);
				}
				if(ammodef2) 
				{
					double ammomax = max(ammodef2.backpackmaxamount, ammodef2.maxamount);
					togive += ammomax-to.countinv(ammotype2);
				}
			}
			if(togive <= 0) return Null;
		}
		else
		{
			// Resolve clip-ammunition.
			to.GiveInventory(trueitem, 1);
			if(noammogive && ammotype1) to.TakeInventory(ammotype1, ammogive1);
			if(ammotype2 && clipammo != -1)
			{
				let clipdefs = GetDefaultByType(ammotype2);
				to.TakeInventory(ammotype2, clipdefs.maxamount);
				to.GiveInventory(ammotype2, clipammo);
			}
		}
			
		Inventory.PrintPickupMessage(to.CheckLocalView(), truepickupmsg);
		to.A_StartSound(truepickupsnd, CHAN_ITEM, CHANF_OVERLAP);
		if(!noammogive) 
		{
			// Fresh weapon pick, give ammogive amounts.
			to.GiveInventory(ammotype1, ammogive1);
			to.GiveInventory(ammotype2, ammogive2);
		}
		else if(hasitem && clipammo != -1)
		{
			// Give amount of ammo loaded in weapon, to reserves.
			to.GiveInventory(ammotype1, clipammo);
		}
        return Weapon(to.FindInventory(trueitem));
	}
	
	void CheckPlrCollide(double distmod=1.0)
	{
		PlayerPawn act;	
		if(haloplr) haloplr.pickuptarget = NULL;
		plr = haloplr = NULL;
		 
		double pickup_dist = (PICKUP_RANGE*distmod)*(PICKUP_RANGE*distmod);
		
		for(int i = 0; i < MAXPLAYERS; i++)
		{
			if(!playerInGame[i]) continue;
			act = players[i].mo;
			
			// If player is colliding with a weaponproxy item, and looking at it.
			if(act && Distance3DSquared(act) <= pickup_dist)
			{
				FLineTraceData lt;
				act.LineTrace(act.angle, visibledist, act.pitch, TRF_ALLACTORS|TRF_ABSOFFSET, act.player.viewheight,0,0, lt);
				Actor hitact = lt.HitActor;
				if(hitact != self) continue;

				haloplr = HaloPlayer(act);

				plr = act;
				if(haloplr && !haloplr.countinv(trueitem)) haloplr.pickuptarget = self;
				break;
			}
		}
	}
	
	void ProcessPickupCollision()
	{
		// Determine if colliding with another weapon, move outside bounds.
		let it = ThinkerIterator.Create("WeaponPickupProxy");
		WeaponPickupProxy curpickup;
		double maxdist = radius*radius;
		while(curpickup = WeaponPickupProxy(it.Next()))
		{
			if(curpickup == self) continue;
			double curdist = Distance2DSquared(curpickup);
			if(curdist > maxdist) continue;
			double angto = frandom(0,360);
			vector2 outpos = (
				cos(angto) * -4,
				sin(angto) * -4
			);
			SetOrigin((pos.x+outpos.x, pos.y+outpos.y, pos.z), true);
		}
	}
		
	override void Tick()
	{
		// Handle physics manually.
		super.tick();
		
		if(pos.z != floorz && abs(vel.z) <= 1) SetOrigin((pos.x,pos.y,floorz), true);
		
		bool hasweap = !plr ? false : !!plr.FindInventory(trueitem);
		CheckPlrCollide(hasweap ? 0.5 : 1.0);
		if(!plr || !plr.player) return;
		ProcessPickupCollision();
			
		// If invalid sprite, use default.
		/*
			if(sprite == GetSpriteIndex("TNT1") || !sprite) 
			{
				sprite = GetSpriteIndex(NOWEAPSPR);
				frame = 0;
			}
		*/
		
		// Determine if current weapon is busy
		let haloweap = HaloGun(plr.player.ReadyWeapon);
		if(haloweap && haloweap.handsbusy && !forcepickup) 
		{
			use_hold = -1;
			return; 
		}
		
		// Count weapons
		let wcontrol = WeaponLimitProxy(plr.FindInventory("WeaponLimitProxy"));
		int wcount = 1;
		if(haloplr && !wcontrol)
		{
			plr.GiveInventory("WeaponLimitProxy",1);
			return;
		} 
		else if(wcontrol)
			wcount = wcontrol.CountWeapons();
			
		// Process pickup
		bool isaimweap = !haloplr ? true : (haloplr.pickuptarget == self);
		if( (!plr.player.ReadyWeapon && wcount > 0) || (!isaimweap && !hasweap) && !forcepickup) 
		{
			use_hold = -1;
			return;
		}
		
		int btns = plr.player.cmd.buttons;
		int oldbtns = plr.player.oldbuttons;
		
		bool use_down = (btns & BT_USE);
		if(use_hold >= 0) 
		{
			use_hold = use_down ? use_hold+1 : 0;
		}
		else if(!use_down)
		{
			use_hold = 0;
		}
		
		if( forcepickup || use_hold > 4 || hasweap || halodoom_unlimitedbackpack || (!haloplr && plr) )
		{
			use_hold = 0;
			if(wcount >= MAXWEAPS && !halodoom_unlimitedbackpack)
			{
				if(!hasweap && wcontrol)
				{
					wcontrol.DropSelectedWeapon(pos);
					let nweap = GiveWeaponItem(plr);
					if(nweap) 
					{
						nweap.Use(true);
						Destroy();
					}
					else forcepickup = false;
					return;
				}
				else if(GiveWeaponItem(plr))
				{
					 Destroy();
					 return;
				}
			}
			else
			{
				bool switchOnPickup = plr.player.GetNeverSwitch() && halodoom_unlimitedbackpack;
				let nweap = GiveWeaponItem(plr);
				if(!hasweap && nweap && !switchOnPickup) nweap.Use(true);
				if(nweap) 
				{
					Destroy();
					return;
				} 
				else forcepickup = false;
			}
		}
	}
	
	States
	{
		Spawn:
			"####" "#" -1;
		stop;
	}
}

class WeaponLimitProxy : Inventory
{
	PlayerPawn plr;
	Default
	{
		inventory.maxamount 1;
		+INVENTORY.UNDROPPABLE;
	}
	
	void DropSelectedWeapon(vector3 atpos)
	{
		if(!plr || !plr.player || !plr.player.ReadyWeapon) return;
		let selweap = plr.player.ReadyWeapon;
		plr.DropWeapon();
		let temp = plr.Spawn(selweap.GetClass(), atpos);
		if(temp) 
		{
			let wp = WeaponPickupProxy.BecomeWeaponProxy(Weapon(temp), true);
			if(wp) wp.clipammo = plr.countinv(selweap.ammotype2);
		}
		if(HaloGun(selweap)) HaloGun(selweap).OnDropSwap();
		plr.player.ReadyWeapon = NULL;
		
		// Interestingly, inventory items stay on the map at ALL times.
		// So, if you remove an item, and you want it completely gone be sure
		// to destroy it as well. If an item doesn't have an owner, it'll remain
		// invisible but it'll be pickupable again. Producing some really funny
		// bugs sometimes.
		plr.RemoveInventory(selweap);
		Inventory(selweap).GoAwayAndDie();
	}
	
	int CountWeapons()
	{
		// Count weapons. (If player is connected to this item)
		if(!plr) return -1;
		int weapcnt = 0;
		for(let item = plr.Inv; item; item = item.inv)
		{
			if(item is "Weapon" && !(item is "Fist")) weapcnt++;
		}
		return weapcnt;
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		plr = PlayerPawn(Owner);
		if(!plr || !plr.player) return;
		
		if(CountWeapons() > MAXWEAPS && !halodoom_unlimitedbackpack) 
		{
			double rang = ceil(frandom(0,90)*4.);
			vector3 fw = ( cos(plr.angle+rang)*32, sin(plr.angle+rang)*32, 0 );
			DropSelectedWeapon(plr.Vec3Offset(fw.x,fw.y,0));
			let nextweap = plr.PickNextWeapon();
			if(nextweap) nextweap.Use(false);
		}
	}
}