
class LaserBeamDecal : CheapActor
{
	Line onWall;
	
	Default
	{
		+ROLLSPRITE;
		+FLATSPRITE;
		+MOVEWITHSECTOR
		RenderStyle "Add";
	}
	
	override void BeginPlay()
	{
		super.BeginPlay();
		roll = frandom[LasDecalRoll](-180,180);
	}
	
	override void Tick()
	{
		super.Tick();	
		HaloMath.AlignToPlane(self, adjustSpeed:90);
		if(onWall)
		{
			angle = atan2(onWall.delta.y, onWall.delta.x) + 90;
			pitch = 90;
		}
	}
		
	States
	{
		Spawn:
			LASH A 0;
		Animate:
			"####" "#" 1 A_Fadeout(0.008);
		wait;
	}
}

class LaserBeam : Actor
{
	Color shade;

	class<LaserBeamDecal> laserDecalType;
	double maxDist;
	int ontics;
	bool enabled;
	Actor source;
	vector3 curPos;
	vector3 offsets;
	vector2 angleOffsets;
	vector3 curOffs;
	transient LaserLineTracer hitData;
	
	bool trackingPos;
	vector3 targetPos;
	
	bool aimWithWeapon;
	bool trackPSprite;
	uint trackPSLayer;
	
	bool followAngles;
	Property TrackAngles : followAngles;
	Property TrackWeapon : trackPSprite, trackPSLayer;
	Property AimFromWeapon : aimWithWeapon; 
	Property LaserColor : shade;
	Property LaserDecal : laserDecalType;
	
	Default
	{
		Scale 1.0;
		+NOINTERACTION;
		+INTERPOLATEANGLES;
		RenderStyle "AddShaded";
		
		LaserBeam.LaserColor "Blue";
		LaserBeam.TrackAngles true;				// Update with player's view.
		LaserBeam.TrackWeapon true, PSP_WEAPON; // Offset by PSprite offsets.
		LaserBeam.AimFromWeapon true;			// Fire from weapon "muzzle", only used if TrackWeapon is enabled.
	}
	
	static LaserBeam Create(Actor source, double fw, double lr, double ud, double angleOffs = 0, double pitchOffs = 0, double maxDist = 64000, class<LaserBeam> type = "LaserBeam")
	{
		let laser = LaserBeam(Spawn(type, source.pos));
		if(laser) 
		{
			laser.source = source;
			laser.target = source;
			laser.maxDist = maxDist;
			laser.offsets = (fw, lr, ud);
			laser.angleOffsets = (angleOffs, pitchOffs);
		}
		
		return laser;
	}
	
	void setEnabled(bool set)
	{
		enabled = set;
	}
	
	void startTracking(vector3 toPos)
	{
		trackingPos = true;
		targetPos = toPos;
	}
	
	void stopTracking()
	{
		if(trackingPos) ontics = 0;
		trackingPos = false;
	}
	
	bool isTracking()
	{
		return trackingPos;
	}
		
	void aimAtCrosshair()
	{
		double zoffs = source.height*0.5;
		if(source.player) zoffs = source.player.viewz - source.pos.z;
		
		FLineTraceData lt;
		source.LineTrace(source.angle, maxDist, source.pitch, offsetz:zoffs, offsetforward:source.radius, data:lt);
		if(lt.HitType != TRACE_HitNone) 
		{
			vector3 aimAngles = level.SphericalCoords(curPos, lt.HitLocation, (source.angle,source.pitch));
			angleOffsets.x = aimAngles.x;
			angleOffsets.y = aimAngles.y;
		}
	}
	
	virtual vector3 getSourcePos()
	{
		vector3 srcPos = (source.pos.xy, source.pos.z + (source.height * 0.5));
		if(source.player) srcPos.z = source.player.viewz;
		
		return srcPos;
	}
	
	virtual void BeamTick()
	{
		// Implement custom laser logic here.
	}
	
	virtual void OnImpact(vector3 hitPos, Actor hitActor)
	{
		if(laserDecalType) DoLaserDecal(laserDecalType, false);
	}
	
	virtual void DoLaserDecal(class<LaserBeamDecal> decalType, bool puffOnActors = false)
	{
		if(hitData.results.hitActor && !puffOnActors) return;
		let dec = LaserBeamDecal(Spawn(decalType, hitData.results.hitPos));
		if(dec) 
		{
			dec.onWall = hitData.results.hitLine;
		}
	}
	
	override void Tick()
	{
		if(isFrozen()) return;
		if(!enabled || !source) 
		{
			ontics = 0;
			bInvisible = true;
			return;
		}
		ontics++;
		bInvisible = ontics < 3;
		if(shade) SetShade(shade);
		
		if(ontics == 2 && hitData)
		{
			OnImpact(hitData.results.hitPos, hitdata.results.hitActor);
		}
				
		// PSprite tracking?
		vector2 bob = (0,0);
		if(trackPSprite && PlayerPawn(source))
		{
			let psp = source.player.GetPSprite(trackPSLayer);
			bob = PlayerPawn(source).BobWeapon(1.0);
			
			bob.x += psp.x;
			bob.y += (psp.y - 32);
			bob.x *= 0.031;
			bob.y *= 0.035;
		}
		
		// Update laser and tracking.
		curOffs = HaloMath.V3Offset(
			source.angle, source.pitch, source.roll,
			offsets.x, offsets.y + bob.x, offsets.z - bob.y, 
			1.0
		);
	
		vector3 finalPos = level.vec3offset(getSourcePos(), curOffs);
		SetOrigin(finalPos, true);
		curPos = finalPos;
		
		double toAngle = angleOffsets.x;
		double toPitch = angleOffsets.y;
		if(followAngles) 
		{
			toAngle += source.angle;
			toPitch += source.pitch;
		}
		
		if(aimWithWeapon) 
		{
			toAngle -= (bob.x * 10);
			toPitch += (bob.y * 10);  
		}	
		
		// Track target and source's angles.
		if(trackingPos)
		{
			vector3 diff = level.vec3diff(finalPos, targetPos);
			vector3 dir = diff.Unit();
			
			toAngle = angleOffsets.x + atan2(dir.y, dir.x) + 180; 
			toPitch = angleOffsets.y + asin(dir.z);
			A_SetAngle(toAngle, SPF_INTERPOLATE);
			A_SetPitch(toPitch - 90, SPF_INTERPOLATE);		
		}
		else
		{
			A_SetAngle(toAngle, SPF_INTERPOLATE);
			A_SetPitch(toPitch+90, SPF_INTERPOLATE);
		}
		
		// View Interpolation.
		if(source.player) source.player.cheats |= CF_INTERPVIEW;
		
		// Do linetrace to determine aim distance.
		double zoffs = source.player ? (source.player.viewz-source.pos.z) : source.height * 0.5;
		if(!hitData)
			hitData = LaserLineTracer.DoTrace(self, self, angle, pitch - 90, maxDist, offsets.x + source.radius, offsets.y-bob.x, offsets.z-bob.y);
		else
			hitData.ReTrace(self, self, angle, pitch - 90, maxDist, offsets.x + source.radius, offsets.y-bob.x, offsets.z-bob.y);
		
		// Scale to Distance.
		double dist = min(hitData.results.Distance, maxDist);
		double dirPitch = pitch - 90;
		scale.y = dist * level.pixelstretch;
					
		BeamTick();
	}
	
	States
	{
		Spawn:
			MODL A -1 Bright;
		stop;
	}
}

class LaserLineTracer : LineTracer
{
	Actor src;
	Actor proj;
	Array<Line> HitLines;
	
	play static LaserLineTracer DoTrace(Actor src, Actor proj, double tangle, double tpitch, double dist, double fw, double lr, double ud, uint traceflags = 0)
	{
		LaserLineTracer tracer = new("LaserLineTracer");
		if(tracer) 
		{
			tracer.proj = proj;
			tracer.src = src;
			vector3 dir = HaloMath.VecFromAngles(tangle, tpitch);
			vector3 tracePos = HaloMath.V3Offset(tangle, tpitch, 0, fw, lr, ud, 1.);
			tracer.Trace(level.vec3offset(src.pos, tracePos), src.CurSector, dir, dist, traceflags);
		}
		return tracer;
	}
	
	play void ReTrace(Actor src, Actor proj, double tangle, double tpitch, double dist, double fw, double lr, double ud, uint traceflags = 0)
	{
		self.src = src;
		self.proj = proj;
		vector3 dir = HaloMath.VecFromAngles(tangle, tpitch);
		vector3 tracePos = HaloMath.V3Offset(tangle, tpitch, 0, fw, lr, ud, 1.);
		Trace(level.vec3offset(src.pos, tracePos), src.CurSector, dir, dist, traceflags);
	}

	// Thanks to PhantomBeta 
	// (https://github.com/Doom2fan/Se7evidas/blob/master/PK3%20Source/S7ZScript/Bases/S7_Projectile/Linetracer.ZS)
    transient Array<F3DFloor> ffloorsToIgnore;
	ETraceStatus HandleWall() 
	{
		let hl = Results.HitLine;
		HitLines.push(hl);
		
        if (Results.Tier == TIER_Upper || Results.Tier == TIER_Lower)
            return TRACE_Stop;

        if (Results.ffloor && ffloorsToIgnore.Find (Results.ffloor) == ffloorsToIgnore.Size ())
		{
            ffloorsToIgnore.Push (Results.ffloor);
            return TRACE_Stop;
        }

        if (Results.Tier == TIER_Middle && !hl.backsector)
			return TRACE_Stop;
			
        if (Results.Tier == TIER_Middle && (hl.flags & Line.ML_Blocking) && (hl.flags & Line.ML_TwoSided))
            return TRACE_Skip;

        if ((hl.flags & Line.ML_3DMidTex) && !(hl.flags & Line.ML_3DMidTex_Impass))
            return TRACE_Stop;

        if (hl.flags & (Line.ML_Blocking | Line.ML_BlockEverything))
            return TRACE_Stop;

        return TRACE_Skip;
    }
	
	override ETraceStatus TraceCallback()
	{
		if(results.HitType == Trace_HitWall)
		{
			let stat = HandleWall();
			return stat;
		}
		if(results.HitType == Trace_HitActor)
		{
			// !results.HitActor.CanCollideWith(src, false)
			if(results.HitActor == src.target || !results.HitActor.bSHOOTABLE)
				return Trace_Skip;
		}
		return Trace_Stop;
	}
}