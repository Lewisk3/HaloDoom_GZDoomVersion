
class LaserBeamDecal : CheapActor
{
	Line onWall;
	
	Default
	{
		+FLATSPRITE;
		+MOVEWITHSECTOR
		RenderStyle "Add";
	}
	
	override void Tick()
	{
		super.Tick();	
		HaloMath.AlignToPlane(self, adjustSpeed:90);
		if(onWall)
		{
			angle = atan2(onWall.delta.y, onWall.delta.x) + 90;
			pitch = 90;
		}
	}
		
	States
	{
		Spawn:
			LASH A 0;
		Animate:
			"####" "#" 1 A_Fadeout(0.008);
		wait;
	}
}

class LaserBeam : Actor
{
	Color shade;

	class<LaserBeamDecal> laserDecalType;
	double maxDist;
	int ontics;
	bool enabled;
	Actor source;
	vector3 offsets;
	vector2 angleOffsets;
	vector3 curOffs;
	transient FLineTraceData hitData;
	
	bool trackingPos;
	vector3 targetPos;
	
	bool aimWithWeapon;
	bool trackPSprite;
	uint trackPSLayer;
	
	bool followAngles;
	Property TrackAngles : followAngles;
	Property TrackWeapon : trackPSprite, trackPSLayer;
	Property AimFromWeapon : aimWithWeapon; 
	Property LaserColor : shade;
	Property LaserDecal : laserDecalType;
	
	Default
	{
		Scale 1.0;
		+NOINTERACTION;
		+INTERPOLATEANGLES;
		RenderStyle "AddShaded";
		
		LaserBeam.LaserColor "Blue";
		LaserBeam.TrackAngles true;				// Update with player's view.
		LaserBeam.TrackWeapon true, PSP_WEAPON; // Offset by PSprite offsets.
		LaserBeam.AimFromWeapon true;			// Fire from weapon "muzzle", only used if TrackWeapon is enabled.
	}
	
	static LaserBeam Create(Actor source, double fw, double lr, double ud, double angleOffs = 0, double pitchOffs = 0, double maxDist = 2048, class<LaserBeam> type = "LaserBeam")
	{
		let laser = LaserBeam(Spawn(type, source.pos));
		if(laser) 
		{
			laser.source = source;
			laser.maxDist = maxDist;
			laser.offsets = (fw, lr, ud);
			laser.angleOffsets = (angleOffs, pitchOffs);
		}
		
		return laser;
	}
	
	void setEnabled(bool set)
	{
		enabled = set;
	}
	
	void startTracking(vector3 toPos)
	{
		trackingPos = true;
		targetPos = toPos;
	}
	
	void stopTracking()
	{
		if(trackingPos) ontics = 0;
		trackingPos = false;
	}
	
	bool isTracking()
	{
		return trackingPos;
	}
	
	virtual vector3 getSourcePos()
	{
		vector3 srcPos = (source.pos.xy, source.pos.z + (source.height * 0.5));
		if(source.player) srcPos.z = source.player.viewz;
		
		return srcPos;
	}
	
	virtual void BeamTick()
	{
		// Implement custom laser logic here.
	}
	
	virtual void OnImpact(vector3 hitPos, Actor hitActor)
	{
		if(laserDecalType) DoLaserDecal(laserDecalType, false);
	}
	
	virtual void DoLaserDecal(class<LaserBeamDecal> decalType, bool puffOnActors = false)
	{
		if(hitData.hitActor && !puffOnActors) return;
		let dec = LaserBeamDecal(Spawn(decalType, hitData.hitLocation));
		if(dec) 
		{
			dec.onWall = hitData.hitLine;
		}
	}
	
	override void Tick()
	{
		if(isFrozen()) return;
		if(!enabled) 
		{
			ontics = 0;
			bInvisible = true;
			return;
		}
		ontics++;
		bInvisible = ontics < 3;
		if(shade) SetShade(shade);
		
		if(ontics == 2)
		{
			OnImpact(hitData.hitLocation, hitdata.hitActor);
		}
				
		// PSprite tracking?
		vector2 bob = (0,0);
		if(trackPSprite)
		{
			let psp = source.player.GetPSprite(trackPSLayer);
			bob = PlayerPawn(source).BobWeapon(1.0);
			
			bob.x += psp.x;
			bob.y += (psp.y - 32);
			bob.x *= 0.031;
			bob.y *= 0.035;
		}
		
		// Update laser and tracking.
		if(!trackingPos || curOffs.Length() ~== 0)
		{
			curOffs = HaloMath.V3Offset(
				source.angle, source.pitch, source.roll,
				offsets.x, offsets.y + bob.x, offsets.z - bob.y, 
				1.0
			);
		}
		
		vector3 finalPos = level.vec3offset(getSourcePos(), curOffs);
		SetOrigin(finalPos, true);
		
		double toAngle = source.angle + angleOffsets.x;
		double toPitch = source.pitch + angleOffsets.y;
		if(aimWithWeapon) 
		{
			toAngle -= (bob.x * 10);
			toPitch += (bob.y * 10);  
		}	
		
		// Track target and source's angles.
		if(trackingPos)
		{
			vector3 diff = level.vec3diff(finalPos, targetPos);
			vector3 dir = diff.Unit();
			
			toAngle = angleOffsets.x + atan2(dir.y, dir.x) + 180; 
			toPitch = angleOffsets.y + asin(dir.z);
			A_SetAngle(toAngle, SPF_INTERPOLATE);
			A_SetPitch(toPitch - 90, SPF_INTERPOLATE);		
		} 
		else if(followAngles)
		{
			A_SetAngle(toAngle, SPF_INTERPOLATE);
			A_SetPitch(toPitch+90, SPF_INTERPOLATE);
		}
		
		// Credits: This interpolation magic was gleaned from Kodi's KLazer library
		// code available in PainSlayer 
		// (https://github.com/jekyllgrim/Painslayer/blob/master/ZPainkiller/klazer/KLAZ_Beam.zsc#L114)
		
		// Odd interpolation magic.
		double prevAngle = source.angle;
		source.A_SetAngle(source.angle + 0.001, SPF_INTERPOLATE);
		source.A_SetAngle(prevAngle, SPF_INTERPOLATE);
		
		// Do linetrace to determine aim distance.
		double zoffs = source.player ? (source.player.viewz-source.pos.z) : source.height * 0.5;
		source.LineTrace(angle, maxDist, pitch - 90, 0, zoffs+offsets.z-bob.y, offsets.x, offsets.y-bob.x, data:hitData);
		
		// Scale to Distance.
		double dist = min(hitData.Distance, maxDist);
		double dirPitch = pitch - 90;
		scale.y = dist * level.pixelstretch;
					
		BeamTick();
	}
	
	States
	{
		Spawn:
			MODL A -1 Bright;
		stop;
	}
}
